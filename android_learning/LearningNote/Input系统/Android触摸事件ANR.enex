<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export3.dtd">
<en-export export-date="20171124T092326Z" application="Evernote" version="Evernote Mac 6.12.2 (455489)">
<note><title>Android触摸事件ANR</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div>ANR(Application Not reponding)指应用程序无响应，Android系统对某些事件并没有在一定时间内完成，超时响应事件就会导致ANR。</div><div>那些场景会导致ANR：</div><ul><li>Service Timeout :20秒内Service未执行完成</li><li>BroadcatQueue TimeOut: 前台广播在10秒内未完成</li><li>ContentProvider TimeOut:内容提供者执行超时</li><li>InputDispatching TimeOut:输入事件分发处理超过5秒</li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>下面是分析InputDispatching TimeOut</div><div><br/></div><div>ANR发生的时机是在findFocusedWindowTargetsLocked内checkWindowReadyForMoreInputLocked，一直等待的原因</div><div>有如下:</div><div>1.Window pause;</div><div>2.和Window之间的connect没有注册;</div><div>3.和Window之间的connect死亡了;</div><div>4.和Window之间的inputPulisher阻塞了;</div><div>5.当前事件是key_event,outboundQueue队列中，或者waitQueue中不为空;</div><div>6.当前事件是touch_event,waitQueue中，事件处理时间大于0.5s。</div><div><br/></div><div>然后再看到handleTargetsNotReadyLocked</div><div>目标还没处理导致阻塞的原因有两种：</div><div>1.applicationHandle和windowHandle都为空，则认为系统还没准备好接收事件;</div><div>2.application没有准备好处理事件。</div><div><br/></div><div>当前这个application没有准备好，直到5s后，那就调用onANRLocked()发生ANR</div><div><br/></div><div>在onANRLocked方法中，做了以下两件事前</div><div><span style="color: rgb(45, 79, 201);">1.先捕捉到ANR线程的信息;</span></div><div><span style="color: rgb(65, 0, 125);">2.然后放到CommonEntry队列当中去,在下次分发消息前先处理CommonEntry队列中的事件runCommandsLockedInterruptible。</span></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void InputDispatcher::onANRLocked(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; nsecs_t currentTime, const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const sp&lt;InputWindowHandle&gt;&amp; windowHandle,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; nsecs_t eventTime, nsecs_t waitStartTime, const char* reason) {</div><div>&nbsp; &nbsp; <span style="color: rgb(45, 79, 201);">float dispatchLatency = (currentTime - eventTime) * 0.000001f;</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; float waitDuration = (currentTime - waitStartTime) * 0.000001f;</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; ALOGI(&quot;Application is not responding: %s.&nbsp; &quot;</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;It has been %0.1fms since event, %0.1fms since wait started.&nbsp; Reason: %s&quot;,</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getApplicationWindowLabelLocked(applicationHandle, windowHandle).string(),</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dispatchLatency, waitDuration, reason);</span></div><div><span style="color: rgb(45, 79, 201);"><br/></span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; // Capture a record of the InputDispatcher state at the time of the ANR.</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; time_t t = time(NULL);</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; struct tm tm;</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; localtime_r(&amp;t, &amp;tm);</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; char timestr[64];</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; strftime(timestr, sizeof(timestr), &quot;%F %T&quot;, &amp;tm);</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; mLastANRState.clear();</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; mLastANRState.append(INDENT &quot;ANR:\n&quot;);</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; mLastANRState.appendFormat(INDENT2 &quot;Time: %s\n&quot;, timestr);</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; mLastANRState.appendFormat(INDENT2 &quot;Window: %s\n&quot;,</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getApplicationWindowLabelLocked(applicationHandle, windowHandle).string());</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; mLastANRState.appendFormat(INDENT2 &quot;DispatchLatency: %0.1fms\n&quot;, dispatchLatency);</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; mLastANRState.appendFormat(INDENT2 &quot;WaitDuration: %0.1fms\n&quot;, waitDuration);</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; mLastANRState.appendFormat(INDENT2 &quot;Reason: %s\n&quot;, reason);</span></div><div><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp; dumpDispatchStateLocked(mLastANRState);</span></div><div><br/></div><div>&nbsp; &nbsp; <span style="color: rgb(65, 0, 125);">CommandEntry* commandEntry = postCommandLocked(</span></div><div><span style="color: rgb(65, 0, 125);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp; InputDispatcher::doNotifyANRLockedInterruptible);</span></div><div><span style="color: rgb(65, 0, 125);">&nbsp; &nbsp; commandEntry-&gt;inputApplicationHandle = applicationHandle;</span></div><div><span style="color: rgb(65, 0, 125);">&nbsp; &nbsp; commandEntry-&gt;inputWindowHandle = windowHandle;</span></div><div><span style="color: rgb(65, 0, 125);">&nbsp; &nbsp; commandEntry-&gt;reason = reason;</span></div><div>}</div></div><div><br/></div><div><span style="color: rgb(45, 79, 201);">1.记录ANR的信息，包括以下的信息</span></div><div><span style="color: rgb(45, 79, 201);">1)当前的时间;</span></div><div><span style="color: rgb(45, 79, 201);">2)当前的Window和Application;</span></div><div><span style="color: rgb(45, 79, 201);">3)当前事件的延时;</span></div><div><span style="color: rgb(45, 79, 201);">4)事件等待超时时间;</span></div><div><span style="color: rgb(45, 79, 201);">5)checkWindowReadyForMoreInputLocked一直等待的原因;</span></div><div><span style="color: rgb(45, 79, 201);">6)当前mFocusApplication信息和mFocusedWindowHandle信息;</span></div><div><span style="color: rgb(45, 79, 201);">7)当前WindowHandles的信息，即分发窗口的信息;</span></div><div><span style="color: rgb(45, 79, 201);">8)当前监视的Channel的信息;</span></div><div><span style="color: rgb(45, 79, 201);">9)最近事件的信息;</span></div><div><span style="color: rgb(45, 79, 201);">10)当前被分发的事件;</span></div><div><span style="color: rgb(45, 79, 201);">11)mInboundQueue即从InputReader发送过来的事件;</span></div><div><span style="color: rgb(45, 79, 201);">12)当前和Window之前的所有连接,包括outboundQueue和waitQueue</span></div><div><span style="color: rgb(45, 79, 201);">13)配置信息mConfig的信息，包括the key重复初始化超时事件500ms，key重复的延时事件50ms.</span></div><div><br/></div><div><span style="color: rgb(65, 0, 125);">2.然后放到CommonEntry队列当中去,在下次分发消息前先处理CommonEntry队列中的事件runCommandsLockedInterruptible，则会调用方法doNotifyANRLockedInterruptible，将底层的事件传递到WindowManagerService去。</span></div><div><span style="color: rgb(65, 0, 125);">1)doNotifyANRLockedInterruptible,通过mPolicy将ANR的applicationHandle和windowHandle传递到上层去，并继续处理事件。</span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void InputDispatcher::doNotifyANRLockedInterruptible(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; CommandEntry* commandEntry) {</div><div>&nbsp; &nbsp; mLock.unlock();</div><div><br/></div><div>&nbsp; &nbsp; nsecs_t newTimeout = mPolicy-&gt;notifyANR(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commandEntry-&gt;inputApplicationHandle, commandEntry-&gt;inputWindowHandle,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commandEntry-&gt;reason);</div><div><br/></div><div>&nbsp; &nbsp; mLock.lock();</div><div><br/></div><div>&nbsp; &nbsp; resumeAfterTargetsNotReadyTimeoutLocked(newTimeout,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commandEntry-&gt;inputWindowHandle != NULL</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? commandEntry-&gt;inputWindowHandle-&gt;getInputChannel() : NULL);</div><div>}</div></div><div><br/></div><div>mPolicy其实就是NativeInputManager，它实现了接口InputDispatcherPolicyInterface，实现即是通过JNI调用InputManagerService的notifyANR接口</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class NativeInputManager : public virtual RefBase,</div><div>&nbsp; &nbsp; public virtual InputReaderPolicyInterface,</div><div>&nbsp; &nbsp; public virtual InputDispatcherPolicyInterface,</div><div>&nbsp; &nbsp; public virtual PointerControllerPolicyInterface {</div><div>protected:</div><div>&nbsp; &nbsp; virtual ~NativeInputManager();</div><div><br/></div><div>public:</div><div>&nbsp; &nbsp; NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper);</div><div>&nbsp; &nbsp; virtual nsecs_t notifyANR(const sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const String8&amp; reason);</div><div>}</div><div><br/></div><div>nsecs_t NativeInputManager::notifyANR(const sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, const String8&amp; reason) {</div><div>#if DEBUG_INPUT_DISPATCHER_POLICY</div><div>&nbsp; &nbsp; ALOGD(&quot;notifyANR&quot;);</div><div>#endif</div><div><br/></div><div>&nbsp; &nbsp; JNIEnv* env = jniEnv();</div><div><br/></div><div>&nbsp; &nbsp; jobject inputApplicationHandleObj =</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getInputApplicationHandleObjLocalRef(env, inputApplicationHandle);</div><div>&nbsp; &nbsp; jobject inputWindowHandleObj =</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getInputWindowHandleObjLocalRef(env, inputWindowHandle);</div><div>&nbsp; &nbsp; jstring reasonObj = env-&gt;NewStringUTF(reason.string());</div><div><br/></div><div>&nbsp; &nbsp; jlong newTimeout = env-&gt;CallLongMethod(mServiceObj,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gServiceClassInfo.notifyANR, inputApplicationHandleObj, inputWindowHandleObj,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reasonObj);</div><div>&nbsp; &nbsp; if (checkAndClearExceptionFromCallback(env, &quot;notifyANR&quot;)) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; newTimeout = 0; // abort dispatch</div><div>&nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; assert(newTimeout &gt;= 0);</div><div>&nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; env-&gt;DeleteLocalRef(reasonObj);</div><div>&nbsp; &nbsp; env-&gt;DeleteLocalRef(inputWindowHandleObj);</div><div>&nbsp; &nbsp; env-&gt;DeleteLocalRef(inputApplicationHandleObj);</div><div>&nbsp; &nbsp; return newTimeout;</div><div>}</div></div><div><br/></div><div>而InputManagerService调用的是mWindowCallback的notifyANR，其实是通过WindowManagerService中的InputMonitor来处理ANR事件</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; &nbsp; private long notifyANR(InputApplicationHandle inputApplicationHandle,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InputWindowHandle inputWindowHandle, String reason) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return mWindowManagerCallbacks.notifyANR(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputApplicationHandle, inputWindowHandle, reason);</div><div>&nbsp; &nbsp; }</div></div><div>&nbsp;</div><div>而WindowManagerCallback是什么时候设置进来的呢？</div><div>在SystemService中startOtherSerive()中</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</div><div>inputManager.start();</div></div><div><br/></div><div>而到此为止，ANR的事件已经从底层传递到上层来了，下面看下上层是如何处理这个ANR事件的呢？</div><div><br/></div><div>上层处理ANR事件的</div><div>1.appWindowToken.appToken不为空,就调用appToken.keyDispatchingTimedOut,否则ActivityManagerNative.getDefault().inputDispatchingTimedOut;</div><div>2.其实上面的情况都是调用到ActivityManagerService.inputDispatchingTimedOut,发送消息到主线程显示一个Dialog，并返回是否要结束Activity;</div><div>3.InputDispatcher根据这个函数的返回值true就是停止Activity了，继续合并继续分发未处理的事件，false是刷新ANR超时的事件，继续等待窗口事件正常。</div><div><br/></div><div>1.appWindowToken.appToken不为空,就调用appToken.keyDispatchingTimedOut,否则ActivityManagerNative.getDefault().inputDispatchingTimedOut;</div><div>下面看InputMonitor的notifyANR的处理流程</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>@Override</div><div>&nbsp; &nbsp; public long notifyANR(InputApplicationHandle inputApplicationHandle,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InputWindowHandle inputWindowHandle, String reason) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; AppWindowToken appWindowToken = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; WindowState windowState = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; boolean aboveSystem = false;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; synchronized (mService.mWindowMap) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (inputWindowHandle != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; windowState = (WindowState) inputWindowHandle.windowState;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (windowState != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appWindowToken = windowState.mAppToken;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (appWindowToken == null &amp;&amp; inputApplicationHandle != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appWindowToken = (AppWindowToken)inputApplicationHandle.appWindowToken;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (windowState != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Slog.i(WindowManagerService.TAG, &quot;Input event dispatching timed out &quot;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;sending to &quot; + windowState.mAttrs.getTitle()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;.&nbsp; Reason: &quot; + reason);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Figure out whether this window is layered above system windows.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // We need to do this here to help the activity manager know how to</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // layer its ANR dialog.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int systemAlertLayer = mService.mPolicy.windowTypeToLayerLw(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aboveSystem = windowState.mBaseLayer &gt; systemAlertLayer;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (appWindowToken != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Slog.i(WindowManagerService.TAG, &quot;Input event dispatching timed out &quot;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;sending to application &quot; + appWindowToken.stringName</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;.&nbsp; Reason: &quot; + reason);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Slog.i(WindowManagerService.TAG, &quot;Input event dispatching timed out &quot;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;.&nbsp; Reason: &quot; + reason);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mService.saveANRStateLocked(appWindowToken, windowState, reason);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (appWindowToken != null &amp;&amp; appWindowToken.appToken != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Notify the activity manager about the timeout and let it decide whether</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // to abort dispatching or keep waiting.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean abort = appWindowToken.appToken.keyDispatchingTimedOut(reason);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (! abort) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // The activity manager declined to abort dispatching.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Wait a bit longer and timeout again later.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return appWindowToken.inputDispatchingTimeoutNanos;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (RemoteException ex) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; } else if (windowState != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Notify the activity manager about the timeout and let it decide whether</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // to abort dispatching or keep waiting.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long timeout = ActivityManagerNative.getDefault().inputDispatchingTimedOut(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; windowState.mSession.mPid, aboveSystem, reason);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (timeout &gt;= 0) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // The activity manager declined to abort dispatching.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Wait a bit longer and timeout again later.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return timeout;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (RemoteException ex) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return 0; // abort dispatching</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>从inputWindowHandle和inputApplicationHandle提取appWindowToken,不为空的话，调用appToken.keyDispatchingTimedOut,这个appToken其实是IApplicationToken,而IWindowToken的服务端的实现是ActivityRecord中的Token类，所以会调用到ActivityRecord中的keyDispatchingTimedOut，这个方法内部其实还是调用到ActivityManagerService方法中的keyDispatchingTimedOut</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp;static class Token extends IApplicationToken.Stub {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; final WeakReference&lt;ActivityRecord&gt; weakActivity;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; Token(ActivityRecord activity) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weakActivity = new WeakReference&lt;ActivityRecord&gt;(activity);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; @Override public boolean keyDispatchingTimedOut(String reason) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ActivityRecord activity = weakActivity.get();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return activity != null &amp;&amp; activity.keyDispatchingTimedOut(reason);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; }</div><div><br/></div><div>public boolean keyDispatchingTimedOut(String reason) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ActivityRecord r;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ProcessRecord anrApp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; synchronized(service) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = getWaitingHistoryRecordLocked();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anrApp = r != null ? r.app : null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return service.inputDispatchingTimedOut(anrApp, r, this, false, reason);</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>而找不到appToken的话，会在mPidsSelfLocked里面找到对应的pid，然后通过远程通信RPC方式调用ActivityManagerService，AMS其实是继承了ActivityManagerNative。</div><div>&nbsp; &nbsp;&nbsp;</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public long inputDispatchingTimedOut(int pid, boolean aboveSystem, String reason)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throws RemoteException {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Parcel data = Parcel.obtain();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Parcel reply = Parcel.obtain();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; data.writeInterfaceToken(IActivityManager.descriptor);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; data.writeInt(pid);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; data.writeInt(aboveSystem ? 1 : 0);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; data.writeString(reason);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mRemote.transact(INPUT_DISPATCHING_TIMED_OUT_TRANSACTION, data, reply, 0);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; reply.readException();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; long res = reply.readInt();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; data.recycle();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; reply.recycle();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return res;</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>下面就是分析AMS中的inputDispatchingTimedOut方法了，假如是debug模式或者mDidDexOpt都会延迟事件ANR等待的事件，其他都是告诉InputDispatcher继续处理事件了，而这里会显示一个dialog，确认就杀死进程，取消则继续等待。</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; &nbsp;mHandler.post(new Runnable() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @Override</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void run() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appNotResponding(proc, activity, parent, aboveSystem, annotation);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });</div><div><br/></div><div>记录当前的堆栈信息</div><div>&nbsp;final void appNotResponding(ProcessRecord app, ActivityRecord activity,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ActivityRecord parent, boolean aboveSystem, final String annotation) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ArrayList&lt;Integer&gt; firstPids = new ArrayList&lt;Integer&gt;(5);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; SparseArray&lt;Boolean&gt; lastPids = new SparseArray&lt;Boolean&gt;(20);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (mController != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 0 == continue, -1 = kill process immediately</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int res = mController.appEarlyNotResponding(app.processName, app.pid, annotation);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (res &lt; 0 &amp;&amp; app.pid != MY_PID) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.kill(&quot;anr&quot;, true);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (RemoteException e) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mController = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Watchdog.getInstance().setActivityController(null);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; long anrTime = SystemClock.uptimeMillis();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (MONITOR_CPU_USAGE) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateCpuStatsNow();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; synchronized (this) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // PowerManager.reboot() can block for a long time, so ignore ANRs while shutting down.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mShuttingDown) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Slog.i(TAG, &quot;During shutdown skipping ANR: &quot; + app + &quot; &quot; + annotation);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (app.notResponding) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Slog.i(TAG, &quot;Skipping duplicate ANR: &quot; + app + &quot; &quot; + annotation);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (app.crashing) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Slog.i(TAG, &quot;Crashing app skipping ANR: &quot; + app + &quot; &quot; + annotation);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // In case we come through here for the same app before completing</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // this one, mark as anring now so we will bail out.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.notResponding = true;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Log the ANR to the event log.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.processName, app.info.flags, annotation);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Dump thread traces as quickly as we can, starting with &quot;interesting&quot; processes.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstPids.add(app.pid);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int parentPid = app.pid;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid &gt; 0) parentPid = parent.app.pid;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (parentPid != app.pid) firstPids.add(parentPid);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (MY_PID != app.pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = mLruProcesses.size() - 1; i &gt;= 0; i--) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessRecord r = mLruProcesses.get(i);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (r != null &amp;&amp; r.thread != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int pid = r.pid;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pid &gt; 0 &amp;&amp; pid != app.pid &amp;&amp; pid != parentPid &amp;&amp; pid != MY_PID) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (r.persistent) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstPids.add(pid);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastPids.put(pid, Boolean.TRUE);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; // Log the ANR to the main log.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; StringBuilder info = new StringBuilder();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; info.setLength(0);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; info.append(&quot;ANR in &quot;).append(app.processName);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (activity != null &amp;&amp; activity.shortComponentName != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info.append(&quot; (&quot;).append(activity.shortComponentName).append(&quot;)&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; info.append(&quot;\n&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; info.append(&quot;PID: &quot;).append(app.pid).append(&quot;\n&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (annotation != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info.append(&quot;Reason: &quot;).append(annotation).append(&quot;\n&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (parent != null &amp;&amp; parent != activity) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info.append(&quot;Parent: &quot;).append(parent.shortComponentName).append(&quot;\n&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; final ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(true);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; File tracesFile = dumpStackTraces(true, firstPids, processCpuTracker, lastPids,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NATIVE_STACKS_OF_INTEREST);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; String cpuInfo = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (MONITOR_CPU_USAGE) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateCpuStatsNow();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized (mProcessCpuTracker) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cpuInfo = mProcessCpuTracker.printCurrentState(anrTime);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info.append(processCpuTracker.printCurrentLoad());</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info.append(cpuInfo);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; info.append(processCpuTracker.printCurrentState(anrTime));</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; Slog.e(TAG, info.toString());</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (tracesFile == null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // There is no trace file, so dump (only) the alleged culprit&apos;s threads to the log</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Process.sendSignal(app.pid, Process.SIGNAL_QUIT);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; addErrorToDropBox(&quot;anr&quot;, app, app.processName, activity, parent, annotation,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cpuInfo, tracesFile, null);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (mController != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 0 == show dialog, 1 = keep waiting, -1 = kill process immediately</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int res = mController.appNotResponding(app.processName, app.pid, info.toString());</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (res != 0) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (res &lt; 0 &amp;&amp; app.pid != MY_PID) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.kill(&quot;anr&quot;, true);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized (this) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mServices.scheduleServiceTimeoutLocked(app);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (RemoteException e) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mController = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Watchdog.getInstance().setActivityController(null);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; // Unless configured otherwise, swallow ANRs in background processes &amp; kill the process.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; synchronized (this) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mBatteryStatsService.noteProcessAnr(app.processName, app.uid);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!showBackground &amp;&amp; !app.isInterestingToUserLocked() &amp;&amp; app.pid != MY_PID) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.kill(&quot;bg anr&quot;, true);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Set the app&apos;s notResponding state, and look up the errorReportReceiver</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; makeAppNotRespondingLocked(app,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activity != null ? activity.shortComponentName : null,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; annotation != null ? &quot;ANR &quot; + annotation : &quot;ANR&quot;,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info.toString());</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Bring up the infamous App Not Responding dialog</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message msg = Message.obtain();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.what = SHOW_NOT_RESPONDING_MSG;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.obj = map;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.arg1 = aboveSystem ? 1 : 0;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map.put(&quot;app&quot;, app);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (activity != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map.put(&quot;activity&quot;, activity);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mHandler.sendMessage(msg);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>然后发送消息给mhandler，显示要不要结束进程，这里的mShowDialogs默认是true的</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>if (mShowDialogs) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dialog d = new AppNotRespondingDialog(ActivityManagerService.this,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mContext, proc, (ActivityRecord)data.get(&quot;activity&quot;),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.arg1 != 0);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d.show();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc.anrDialog = d;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Just kill the app if there is no dialog to be shown.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; killAppAtUsersRequest(proc, null);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div></div><div><br/></div><div>不同选择的方式，选择的是等待的话，会到20s之后再显示Dialog</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>private final Handler mHandler = new Handler() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; public void handleMessage(Message msg) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Intent appErrorIntent = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch (msg.what) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case FORCE_CLOSE:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Kill the application.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mService.killAppAtUsersRequest(mProc, AppNotRespondingDialog.this);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case WAIT_AND_REPORT:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case WAIT:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Continue waiting for the application.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized (mService) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessRecord app = mProc;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (msg.what == WAIT_AND_REPORT) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appErrorIntent = mService.createAppErrorIntentLocked(app,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.currentTimeMillis(), null);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.notResponding = false;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.notRespondingReport = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (app.anrDialog == AppNotRespondingDialog.this) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.anrDialog = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mService.mServices.scheduleServiceTimeoutLocked(app);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (appErrorIntent != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getContext().startActivity(appErrorIntent);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (ActivityNotFoundException e) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Slog.w(TAG, &quot;bug report receiver dissappeared&quot;, e);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; };</div></div><div><br/></div><div>这里又回到了ActivityManagerService</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; &nbsp; void scheduleServiceTimeoutLocked(ProcessRecord proc) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (proc.executingServices.size() == 0 || proc.thread == null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; long now = SystemClock.uptimeMillis();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Message msg = mAm.mHandler.obtainMessage(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ActivityManagerService.SERVICE_TIMEOUT_MSG);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; msg.obj = proc;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mAm.mHandler.sendMessageAtTime(msg,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT)); <span style="color: rgb(227, 0, 0);"><b>//后台和前台结束的时间不同</b></span></div><div>&nbsp; &nbsp; }</div><div><br/></div><div>&nbsp;case SERVICE_TIMEOUT_MSG: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mDidDexOpt) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mDidDexOpt = false;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmsg.obj = msg.obj;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mServices.serviceTimeout((ProcessRecord)msg.obj);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } break;</div></div><div>等待SERVICE_TIMEOUT /SERVICE_BACKGROUND_TIMEOUT 后，又调用到ActiveServices,假如AMS中缓存的mLruProcesses包含当前的process的话，那么就重新调用AMS中appNotResponding显示Dialog，如此重复，直到用户点了关闭。//关闭手机可能也会有ANR，所以PowerManager.reboot() can block for a long time, so ignore ANRs while shutting down.</div><div>用户假如点击了关闭</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case FORCE_CLOSE:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Kill the application.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mService.killAppAtUsersRequest(mProc, AppNotRespondingDialog.this);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</div><div><br/></div><div>&nbsp; &nbsp; void killAppAtUsersRequest(ProcessRecord app, Dialog fromDialog) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; synchronized (this) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.crashing = false;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.crashingReport = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.notResponding = false;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.notRespondingReport = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (app.anrDialog == fromDialog) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.anrDialog = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (app.waitDialog == fromDialog) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.waitDialog = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; handleAppCrashLocked(app, null, null, null);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.kill(&quot;user request after error&quot;, true);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>3.InputDispatcher中的InputMonitor会返回一个时间</div><div>keyDispatchingTimedOut假如是false的话，就会返回一个newTimeOut,否则的话，会把这些事件都发送出去。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void InputDispatcher::resumeAfterTargetsNotReadyTimeoutLocked(nsecs_t newTimeout,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const sp&lt;InputChannel&gt;&amp; inputChannel) {</div><div>&nbsp; &nbsp; if (newTimeout &gt; 0) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // Extend the timeout.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mInputTargetWaitTimeoutTime = now() + newTimeout;</div><div>&nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // Give up.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mInputTargetWaitTimeoutExpired = true;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; // Input state will not be realistic.&nbsp; Mark it out of sync.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (inputChannel.get()) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssize_t connectionIndex = getConnectionIndexLocked(inputChannel);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (connectionIndex &gt;= 0) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp&lt;InputWindowHandle&gt; windowHandle = connection-&gt;inputWindowHandle;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (windowHandle != NULL) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const InputWindowInfo* info = windowHandle-&gt;getInfo();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (info) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssize_t stateIndex = mTouchStatesByDisplay.indexOfKey(info-&gt;displayId);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (stateIndex &gt;= 0) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mTouchStatesByDisplay.editValueAt(stateIndex).removeWindow(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; windowHandle);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (connection-&gt;status == Connection::STATUS_NORMAL) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CancelationOptions options(CancelationOptions::CANCEL_ALL_EVENTS,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;application not responding&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synthesizeCancelationEventsForConnectionLocked(connection, options);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div><div>}</div></div><div><br/></div><div>假如这个Window还有其他事件还没有发送出去的话，那么就将这些事件合并一起发送出去</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void InputDispatcher::synthesizeCancelationEventsForConnectionLocked(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const sp&lt;Connection&gt;&amp; connection, const CancelationOptions&amp; options) {</div><div>&nbsp; &nbsp; if (connection-&gt;status == Connection::STATUS_BROKEN) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; nsecs_t currentTime = now();</div><div><br/></div><div>&nbsp; &nbsp; Vector&lt;EventEntry*&gt; cancelationEvents;</div><div>&nbsp; &nbsp; connection-&gt;inputState.synthesizeCancelationEvents(currentTime,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cancelationEvents, options);</div><div><br/></div><div>&nbsp; &nbsp; if (!cancelationEvents.isEmpty()) {</div><div>#if DEBUG_OUTBOUND_EVENT_DETAILS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ALOGD(&quot;channel &apos;%s&apos; ~ Synthesized %d cancelation events to bring channel back in sync &quot;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;with reality: %s, mode=%d.&quot;,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connection-&gt;getInputChannelName(), cancelationEvents.size(),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options.reason, options.mode);</div><div>#endif</div><div>&nbsp; &nbsp; &nbsp; &nbsp; for (size_t i = 0; i &lt; cancelationEvents.size(); i++) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventEntry* cancelationEventEntry = cancelationEvents.itemAt(i);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch (cancelationEventEntry-&gt;type) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case EventEntry::TYPE_KEY:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logOutboundKeyDetailsLocked(&quot;cancel - &quot;,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; static_cast&lt;KeyEntry*&gt;(cancelationEventEntry));</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case EventEntry::TYPE_MOTION:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logOutboundMotionDetailsLocked(&quot;cancel - &quot;,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; static_cast&lt;MotionEntry*&gt;(cancelationEventEntry));</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InputTarget target;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp&lt;InputWindowHandle&gt; windowHandle = getWindowHandleLocked(connection-&gt;inputChannel);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (windowHandle != NULL) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const InputWindowInfo* windowInfo = windowHandle-&gt;getInfo();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target.xOffset = -windowInfo-&gt;frameLeft;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target.yOffset = -windowInfo-&gt;frameTop;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target.scaleFactor = windowInfo-&gt;scaleFactor;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target.xOffset = 0;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target.yOffset = 0;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target.scaleFactor = 1.0f;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target.inputChannel = connection-&gt;inputChannel;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target.flags = InputTarget::FLAG_DISPATCH_AS_IS;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enqueueDispatchEntryLocked(connection, cancelationEventEntry, // increments ref</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;target, InputTarget::FLAG_DISPATCH_AS_IS);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cancelationEventEntry-&gt;release();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; startDispatchCycleLocked(currentTime, connection);</div><div>&nbsp; &nbsp; }</div><div>}</div></div><div><br/></div><div>进过研究，只要出现ANR窗口的话，那么ANR窗口会一直提示，直到进程被杀死</div><div><a href="http://www.cnblogs.com/zl1991/p/6873581.html">http://www.cnblogs.com/zl1991/p/6873581.html</a></div></en-note>]]></content><created>20170820T092614Z</created><updated>20170824T151801Z</updated><note-attributes><author>1009439210@qq.com</author><source>desktop.win</source><source-application>evernote.win32</source-application><reminder-order>0</reminder-order></note-attributes></note>
</en-export>
