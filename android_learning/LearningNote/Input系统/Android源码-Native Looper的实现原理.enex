<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export3.dtd">
<en-export export-date="20171124T092300Z" application="Evernote" version="Evernote Mac 6.12.2 (455489)">
<note><title>Android源码-Native Looper的实现原理</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">
<en-note><div><font style="font-size: 11px;">Looper.h 头文件分析</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">Looper_callbackFunc</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">typedef int (*Looper_callbackFunc)(int fd, int events, void* data);</font></div><div><font style="font-size: 11px;">//定义Looper_callback的构造函数</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">struct Message</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">struct Message {</font></div><div><font style="font-size: 11px;">    Message() : what(0) { }</font></div><div><font style="font-size: 11px;">    Message(int what) : what(what) { }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    /* The message type. (interpretation is left up to the handler) */</font></div><div><font style="font-size: 11px;">    int what;</font></div><div><font style="font-size: 11px;">}; //定义Message的结构体</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">WeakMessageHandler</font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">class WeakMessageHandler : public MessageHandler {</font></div><div><font style="font-size: 11px;">protected:</font></div><div><font style="font-size: 11px;">    virtual ~WeakMessageHandler();</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">public:</font></div><div><font style="font-size: 11px;">    WeakMessageHandler(const wp&lt;MessageHandler&gt;&amp; handler);</font></div><div><font style="font-size: 11px;">    virtual void handleMessage(const Message&amp; message);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">private:</font></div><div><font style="font-size: 11px;">    wp&lt;MessageHandler&gt; mHandler;</font></div><div><font style="font-size: 11px;">};//一个简单的代理持有MessageHandler的弱引用</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">LooperCallback</font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">class LooperCallback : public virtual RefBase {</font></div><div><font style="font-size: 11px;">protected:</font></div><div><font style="font-size: 11px;">    virtual ~LooperCallback() { }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">public:</font></div><div><font style="font-size: 11px;">    virtual int handleEvent(int fd, int events, void* data) = 0;</font></div><div><font style="font-size: 11px;">};//LooperCallback定义用于处理事件</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">class SimpleLooperCallback : public LooperCallback {</font></div><div><font style="font-size: 11px;">protected:</font></div><div><font style="font-size: 11px;">    virtual ~SimpleLooperCallback();</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">public:</font></div><div><font style="font-size: 11px;">    SimpleLooperCallback(Looper_callbackFunc callback);</font></div><div><font style="font-size: 11px;">    virtual int handleEvent(int fd, int events, void* data);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">private:</font></div><div><font style="font-size: 11px;">    Looper_callbackFunc mCallback;</font></div><div><font style="font-size: 11px;">};//一个简单的LooperCallback，持有Looper_callbackFunc</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">Looper的内部变量及函数</font></div><div><font style="font-size: 11px;"> </font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">enum {</font></div><div><font style="font-size: 11px;">        POLL_WAKE = -1,//POLL是被唤醒,并且没有callback执行或者没有fileDecriptor准备好</font></div><div><font style="font-size: 11px;">     </font></div><div><font style="font-size: 11px;">        POLL_CALLBACK = -2,//代表一个或者多个callback被执行</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        POLL_TIMEOUT = -3,//代表超时</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        POLL_ERROR = -4,//代表发送错误</font></div><div><font style="font-size: 11px;">};//这个枚举的代表函数Looper_pollOnce()和Looper_pollAll()的返回结果</font></div><div><font style="font-size: 11px;">    </font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">enum {</font></div><div><font style="font-size: 11px;">      </font></div><div><font style="font-size: 11px;">        EVENT_INPUT = 1 &lt;&lt; 0,//代表文件描述符可读</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        EVENT_OUTPUT = 1 &lt;&lt; 1,//代表文件描述符可写</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        EVENT_ERROR = 1 &lt;&lt; 2,//代表文件描述符发送错误</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        EVENT_HANGUP = 1 &lt;&lt; 3,//代表文件描述符关闭.比如socket断开</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        EVENT_INVALID = 1 &lt;&lt; 4,//代表文件描述符不可用</font></div><div><font style="font-size: 11px;">    };//该枚举代表一个Looper监听到文件描述符事件标识</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">    enum {</font></div><div><font style="font-size: 11px;">        PREPARE_ALLOW_NON_CALLBACKS = 1&lt;&lt;0 //Looper会调用Looper_addFd时候没有callback，这种情况下，调用Looper_pollOnce()或者Looper_pollAll()必须检查这些函数的返回值，以至于当fds中有可用的数据并处理它</font></div><div><font style="font-size: 11px;">    };//Looper_prepare的选项</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">Looper(bool allowNonCallbacks);//创建Looper，当allNonCallbacks为true时，这个Looper会允许文件描述符创建没有相关的callback</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">bool getAllowNonCallbacks() const;//创建Looper，</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">   int pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData);</font></div><div><font style="font-size: 11px;">    inline int pollOnce(int timeoutMillis) {</font></div><div><font style="font-size: 11px;">        return pollOnce(timeoutMillis, NULL, NULL, NULL);</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">当可选超时，等待事件可用，调用callbacks给所有fd，当一个事件发生时</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">假如超时为0，将立刻返回</font></div><div><font style="font-size: 11px;">假如超时未负数，等待到事件发生</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">这个函数会等待到所有的callback都调用完。</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">    int pollAll(int timeoutMillis, int* outFd, int* outEvents, void** outData);</font></div><div><font style="font-size: 11px;">    inline int pollAll(int timeoutMillis) {</font></div><div><font style="font-size: 11px;">        return pollAll(timeoutMillis, NULL, NULL, NULL);</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;">/**</font></div><div><font style="font-size: 11px;">     和pollOnce()，不过直到所有的data被消耗或者一个fd可用没有回调时，才执行所有的等待的callback，这个函数永远都不会返回POLL_CALLBACK</font></div><div><font style="font-size: 11px;">**/</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">void wake();//异步地唤醒poll，该方法可以被任何线程调用，并且是立刻返回的</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">int addFd(int fd, int ident, int events, Looper_callbackFunc callback, void* data);</font></div><div><font style="font-size: 11px;">int addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data);</font></div><div><font style="font-size: 11px;">//通过Looper，添加一个新的fd被监听，相同的fd，会被后一个更新</font></div><div><font style="font-size: 11px;">fd：文件描述符</font></div><div><font style="font-size: 11px;">ident:这个事件的证明，通过pollOnce()返回，这个indent必须大于等于0或者POLL_CALLBACK （假如提供了不为空的callback）</font></div><div><font style="font-size: 11px;">events:是poll events 去唤醒的。</font></div><div><font style="font-size: 11px;">callback:是这个会被调用，当fd中有事件</font></div><div><font style="font-size: 11px;">data:是一个私有的数据指针供应给这个callback</font></div><div><font style="font-size: 11px;">这个函数的主要两个作用:</font></div><div><font style="font-size: 11px;">1.当callback不为空，当fd中有数据了就会被调用, 这应该执行所有的等待的事件，适适当地从fd中读取，这个ident会被忽略在这种情况下;</font></div><div><font style="font-size: 11px;">2.当callback为空，这个ident会被通过Looper_pollOnce返回，当fd中有可用的数据，需要调用者需要小心处理它</font></div><div><font style="font-size: 11px;">return 1 表示fd被加入了，0表示参数不可用</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;"> int removeFd(int fd);//remove fd ,当该函数返回时，会安全的关闭fd，直到Looper不在引用它，返回1表示被移除，返回0表示fd并不存在</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">void sendMessage(const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message);//通过这个指定的handler处理message，并入队列。</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">void sendMessageDelayed(nsecs_t uptimeDelay, const sp&lt;MessageHandler&gt;&amp; handler,</font></div><div><font style="font-size: 11px;">            const Message&amp; message);</font></div><div><font style="font-size: 11px;">//通过这个指定的handler处理message，并入队列，经过指定的延时</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">void sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler,</font></div><div><font style="font-size: 11px;">            const Message&amp; message);</font></div><div><font style="font-size: 11px;">//通过这个指定的handler处理message，并在指定的时间，入队列</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">void removeMessages(const sp&lt;MessageHandler&gt;&amp; handler);</font></div><div><font style="font-size: 11px;">//通过指定handler，来移除队列中的所有的消息</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">void removeMessages(const sp&lt;MessageHandler&gt;&amp; handler, int what);</font></div><div><font style="font-size: 11px;">//通过指定的handler，来移除队列中指定的消息</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">bool isPolling() const;//判断looper thread是否在poolling</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">static sp&lt;Looper&gt; prepare(int opts);//创建一个looper关联上调用线程，并返回Looper，假如已经有了Looper，就返回，没有的话，就创建一个Looper关联线程后，返回</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">static void setForThread(const sp&lt;Looper&gt;&amp; looper);</font></div><div><font style="font-size: 11px;">//替换当前线程的looper，假如Looper为空的话，那么会移除当前的looper</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">static sp&lt;Looper&gt; getForThread();</font></div><div><font style="font-size: 11px;">//获取当前线程的Looper</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">private:</font></div><div><font style="font-size: 11px;">    struct Request {//将addFd传进来的数据封装，并设置为response的成员变量</font></div><div><font style="font-size: 11px;">        int fd;//fd</font></div><div><font style="font-size: 11px;">        int ident;</font></div><div><font style="font-size: 11px;">        int events;//根据events的类型来设置EPOLL</font></div><div><font style="font-size: 11px;">        int seq;</font></div><div><font style="font-size: 11px;">        sp&lt;LooperCallback&gt; callback;</font></div><div><font style="font-size: 11px;">        void* data;</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        void initEventItem(struct epoll_event* eventItem) const;</font></div><div><font style="font-size: 11px;">     //初始化epoll_event成员变量</font></div><div><font style="font-size: 11px;">    };</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    struct Response {</font></div><div><font style="font-size: 11px;">        int events;//epoll_event_type</font></div><div><font style="font-size: 11px;">        Request request;</font></div><div><font style="font-size: 11px;">    };</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    struct MessageEnvelope {//包装了的消息队列</font></div><div><font style="font-size: 11px;">        MessageEnvelope() : uptime(0) { }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        MessageEnvelope(nsecs_t uptime, const sp&lt;MessageHandler&gt; handler,</font></div><div><font style="font-size: 11px;">                const Message&amp; message) : uptime(uptime), handler(handler), message(message) {</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        nsecs_t uptime;//回调的事件</font></div><div><font style="font-size: 11px;">        sp&lt;MessageHandler&gt; handler;//回调对应的handler</font></div><div><font style="font-size: 11px;">        Message message;//消息</font></div><div><font style="font-size: 11px;">    };</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    const bool mAllowNonCallbacks; // immutable 唯一不变的</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    int mWakeEventFd;  // immutable 唯一不变的</font></div><div><font style="font-size: 11px;">    Mutex mLock;//这个对象的锁</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    Vector&lt;MessageEnvelope&gt; mMessageEnvelopes; // guarded by mLock 要加锁</font></div><div><font style="font-size: 11px;">    bool mSendingMessage; // guarded by mLock 要加锁</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Whether we are currently waiting for work.  Not protected by a lock,</font></div><div><font style="font-size: 11px;">    // any use of it is racy anyway.</font></div><div><font style="font-size: 11px;">    volatile bool mPolling;</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    int mEpollFd; // guarded by mLock but only modified on the looper thread 需要加锁并且只被Looper thread修改</font></div><div><font style="font-size: 11px;">    bool mEpollRebuildRequired; // guarded by mLock 要加锁</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Locked list of file descriptor monitoring requests.</font></div><div><font style="font-size: 11px;">    KeyedVector&lt;int, Request&gt; mRequests;  // guarded by mLock request的键值对</font></div><div><font style="font-size: 11px;">    int mNextRequestSeq;//下一个请求</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // This state is only used privately by pollOnce and does not require a lock since</font></div><div><font style="font-size: 11px;">    // it runs on a single thread.</font></div><div><font style="font-size: 11px;">    Vector&lt;Response&gt; mResponses;//response的vector</font></div><div><font style="font-size: 11px;">    size_t mResponseIndex;//response的index</font></div><div><font style="font-size: 11px;">    nsecs_t mNextMessageUptime; // set to LLONG_MAX when none  //下一个消息的事件</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    int pollInner(int timeoutMillis);//内部的poll逻辑</font></div><div><font style="font-size: 11px;">    int removeFd(int fd, int seq);//removeFd</font></div><div><font style="font-size: 11px;">    void awoken();//唤醒线程函数 TEMP_FAILURE_RETRY用来忽略系统终端造成的错误</font></div><div><font style="font-size: 11px;">    void pushResponse(int events, const Request&amp; request);//将request和events封装到mResponses vector中</font></div><div><font style="font-size: 11px;">    void rebuildEpollLocked();//重新rebuidEpollLocoked</font></div><div><font style="font-size: 11px;">    void scheduleEpollRebuildLocked();//在addFd之后，调用此函数，向mWakeEventFd中写事件</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    static void initTLSKey();//将初始化gTLSKey,并和Looper作为键值对，放到pthread中去</font></div><div><font style="font-size: 11px;">    static void threadDestructor(void *st);//删除强指针</font></div><div><font style="font-size: 11px;">    static void initEpollEvent(struct epoll_event* eventItem);//初始化EpollEvent</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">首先，先调用静态函数Looper::prepare初始化Looper，并返回Looper的强指针对象，调用pthread_key_create创建gTLSKey对象，并从pthread_getspecific(gTLSKey)对象获取到Looper对象，并设置当前的Looper，更新当前的Looper，并将旧Looper对象进行删除</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">sp&lt;Looper&gt; Looper::prepare(int opts) {</font></div><div><font style="font-size: 11px;">    bool allowNonCallbacks = opts &amp; PREPARE_ALLOW_NON_CALLBACKS;</font></div><div><font style="font-size: 11px;">    sp&lt;Looper&gt; looper = Looper::getForThread();</font></div><div><font style="font-size: 11px;">    if (looper == NULL) {</font></div><div><font style="font-size: 11px;">        looper = new Looper(allowNonCallbacks);</font></div><div><font style="font-size: 11px;">        Looper::setForThread(looper);</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;">    if (looper-&gt;getAllowNonCallbacks() != allowNonCallbacks) {</font></div><div><font style="font-size: 11px;">        ALOGW(&quot;Looper already prepared for this thread with a different value for the &quot;</font></div><div><font style="font-size: 11px;">                &quot;LOOPER_PREPARE_ALLOW_NON_CALLBACKS option.&quot;);</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    return looper;</font></div><div><font style="font-size: 11px;">}</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">获取当前Looper</font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">sp&lt;Looper&gt; Looper::getForThread() {</font></div><div><font style="font-size: 11px;">    int result = pthread_once(&amp; gTLSOnce, initTLSKey);</font></div><div><font style="font-size: 11px;">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;pthread_once failed&quot;);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    return (Looper*)pthread_getspecific(gTLSKey);</font></div><div><font style="font-size: 11px;">}</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">Looper并不存在的话，那么就new Looper，并设置当前Looper到pthread中去。</font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">void Looper::setForThread(const sp&lt;Looper&gt;&amp; looper) {</font></div><div><font style="font-size: 11px;">    sp&lt;Looper&gt; old = getForThread(); // also has side-effect of initializing TLS</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    if (looper != NULL) {</font></div><div><font style="font-size: 11px;">        looper-&gt;incStrong((void*)threadDestructor);</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    pthread_setspecific(gTLSKey, looper.get());</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    if (old != NULL) {</font></div><div><font style="font-size: 11px;">        old-&gt;decStrong((void*)threadDestructor);</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;">}</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">然后，将FD加到mRequest键值对中去，已经存在在mRequest中的话，就通过epoll修改文件描述符的，修改失败的话，将重新增加一个fd到epoll监听中去，然后异步的重建epoll;否则就加到mRequest中去。</font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">int Looper::addFd(int fd, int ident, int events, Looper_callbackFunc callback, void* data) {</font></div><div><font style="font-size: 11px;">    return addFd(fd, ident, events, callback ? new SimpleLooperCallback(callback) : NULL, data);</font></div><div><font style="font-size: 11px;">}</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data) {</font></div><div><font style="font-size: 11px;">#if DEBUG_CALLBACKS</font></div><div><font style="font-size: 11px;">    ALOGD(&quot;%p ~ addFd - fd=%d, ident=%d, events=0x%x, callback=%p, data=%p&quot;, this, fd, ident,</font></div><div><font style="font-size: 11px;">            events, callback.get(), data);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    if (!callback.get()) {</font></div><div><font style="font-size: 11px;">        if (! mAllowNonCallbacks) {</font></div><div><font style="font-size: 11px;">            ALOGE(&quot;Invalid attempt to set NULL callback but not allowed for this looper.&quot;);</font></div><div><font style="font-size: 11px;">            return -1;</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        if (ident &lt; 0) {</font></div><div><font style="font-size: 11px;">            ALOGE(&quot;Invalid attempt to set NULL callback with ident &lt; 0.&quot;);</font></div><div><font style="font-size: 11px;">            return -1;</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">    } else {</font></div><div><font style="font-size: 11px;">        ident = POLL_CALLBACK;</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    { // acquire lock</font></div><div><font style="font-size: 11px;">        AutoMutex _l(mLock);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        Request request;</font></div><div><font style="font-size: 11px;">        request.fd = fd;</font></div><div><font style="font-size: 11px;">        request.ident = ident;</font></div><div><font style="font-size: 11px;">        request.events = events;</font></div><div><font style="font-size: 11px;">        request.seq = mNextRequestSeq++;</font></div><div><font style="font-size: 11px;">        request.callback = callback;</font></div><div><font style="font-size: 11px;">        request.data = data;</font></div><div><font style="font-size: 11px;">        if (mNextRequestSeq == -1) mNextRequestSeq = 0; // reserve sequence number -1</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        struct epoll_event eventItem;</font></div><div><font style="font-size: 11px;">        request.initEventItem(&amp;eventItem);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        ssize_t requestIndex = mRequests.indexOfKey(fd);</font></div><div><font style="font-size: 11px;">        if (requestIndex &lt; 0) {</font></div><div><font style="font-size: 11px;">            int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</font></div><div><font style="font-size: 11px;">            if (epollResult &lt; 0) {</font></div><div><font style="font-size: 11px;">                ALOGE(&quot;Error adding epoll events for fd %d: %s&quot;, fd, strerror(errno));</font></div><div><font style="font-size: 11px;">                return -1;</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;">            mRequests.add(fd, request);</font></div><div><font style="font-size: 11px;">        } else {</font></div><div><font style="font-size: 11px;">            int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);</font></div><div><font style="font-size: 11px;">            if (epollResult &lt; 0) {</font></div><div><font style="font-size: 11px;">                if (errno == ENOENT) {</font></div><div><font style="font-size: 11px;">                    // Tolerate ENOENT because it means that an older file descriptor was</font></div><div><font style="font-size: 11px;">                    // closed before its callback was unregistered and meanwhile a new</font></div><div><font style="font-size: 11px;">                    // file descriptor with the same number has been created and is now</font></div><div><font style="font-size: 11px;">                    // being registered for the first time.  This error may occur naturally</font></div><div><font style="font-size: 11px;">                    // when a callback has the side-effect of closing the file descriptor</font></div><div><font style="font-size: 11px;">                    // before returning and unregistering itself.  Callback sequence number</font></div><div><font style="font-size: 11px;">                    // checks further ensure that the race is benign.</font></div><div><font style="font-size: 11px;">                    //</font></div><div><font style="font-size: 11px;">                    // Unfortunately due to kernel limitations we need to rebuild the epoll</font></div><div><font style="font-size: 11px;">                    // set from scratch because it may contain an old file handle that we are</font></div><div><font style="font-size: 11px;">                    // now unable to remove since its file descriptor is no longer valid.</font></div><div><font style="font-size: 11px;">                    // No such problem would have occurred if we were using the poll system</font></div><div><font style="font-size: 11px;">                    // call instead, but that approach carries others disadvantages.</font></div><div><font style="font-size: 11px;">#if DEBUG_CALLBACKS</font></div><div><font style="font-size: 11px;">                    ALOGD(&quot;%p ~ addFd - EPOLL_CTL_MOD failed due to file descriptor &quot;</font></div><div><font style="font-size: 11px;">                            &quot;being recycled, falling back on EPOLL_CTL_ADD: %s&quot;,</font></div><div><font style="font-size: 11px;">                            this, strerror(errno));</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;">                    epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</font></div><div><font style="font-size: 11px;">                    if (epollResult &lt; 0) {</font></div><div><font style="font-size: 11px;">                        ALOGE(&quot;Error modifying or adding epoll events for fd %d: %s&quot;,</font></div><div><font style="font-size: 11px;">                                fd, strerror(errno));</font></div><div><font style="font-size: 11px;">                        return -1;</font></div><div><font style="font-size: 11px;">                    }</font></div><div><font style="font-size: 11px;">                    scheduleEpollRebuildLocked();</font></div><div><font style="font-size: 11px;">                } else {</font></div><div><font style="font-size: 11px;">                    ALOGE(&quot;Error modifying epoll events for fd %d: %s&quot;, fd, strerror(errno));</font></div><div><font style="font-size: 11px;">                    return -1;</font></div><div><font style="font-size: 11px;">                }</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;">            mRequests.replaceValueAt(requestIndex, request);</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">    } // release lock</font></div><div><font style="font-size: 11px;">    return 1;</font></div><div><font style="font-size: 11px;">}</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">然后上层的代码会一直循环调用pollOnce接口，处理消息和事件</font></div><div><font style="font-size: 11px;">1.循环mResponses&lt;Vector&gt;,找到indent大于0的话，就将outFd和outEvents返回，即处理新消息前会将原来的消息清空;</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"> </font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">       while (mResponseIndex &lt; mResponses.size()) {</font></div><div><font style="font-size: 11px;">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</font></div><div><font style="font-size: 11px;">            int ident = response.request.ident;</font></div><div><font style="font-size: 11px;">            if (ident &gt;= 0) {</font></div><div><font style="font-size: 11px;">                int fd = response.request.fd;</font></div><div><font style="font-size: 11px;">                int events = response.events;</font></div><div><font style="font-size: 11px;">                void* data = response.request.data;</font></div><div><font style="font-size: 11px;">#if DEBUG_POLL_AND_WAKE</font></div><div><font style="font-size: 11px;">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</font></div><div><font style="font-size: 11px;">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</font></div><div><font style="font-size: 11px;">                        this, ident, fd, events, data);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;">                if (outFd != NULL) *outFd = fd;</font></div><div><font style="font-size: 11px;">                if (outEvents != NULL) *outEvents = events;</font></div><div><font style="font-size: 11px;">                if (outData != NULL) *outData = data;</font></div><div><font style="font-size: 11px;">                return ident;</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;">        }</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">2.上一次pollInner的result不为空时，将返回空的outFd和outEvents;</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">        if (result != 0) {</font></div><div><font style="font-size: 11px;">#if DEBUG_POLL_AND_WAKE</font></div><div><font style="font-size: 11px;">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;">            if (outFd != NULL) *outFd = 0;</font></div><div><font style="font-size: 11px;">            if (outEvents != NULL) *outEvents = 0;</font></div><div><font style="font-size: 11px;">            if (outData != NULL) *outData = NULL;</font></div><div><font style="font-size: 11px;">            return result;</font></div><div><font style="font-size: 11px;">        }</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">3.pollInner的处理比较复杂，分为下面几个步骤</font></div><div><font style="font-size: 11px;">1)先将mResponses清空，并进入阻塞等待状态，超时时间为下一个message处理的时间;</font></div><div><font style="font-size: 11px;">2)需要重新rebuildRequired的话，即有wake事件时、或者addFd时，将重新创建一个新的mEpollFd，并将事件mRequest键值对中的fd重新加入监听;</font></div><div><font style="font-size: 11px;">3)有wake事件将重新awoken，否则将wake事件读出，否则将fd事件都封装成reponse队列，下次pollOnce将回调给上层;</font></div><div><font style="font-size: 11px;">4)将循环地将需要处理的Message都通过对于的handler回调给上层，并指出下一个Message需要处理的事件时间;</font></div><div><font style="font-size: 11px;">5)将循环地将mReponse队列中的request取出，需要回调上层的话，将调用request.callback回调事件给上层，成功后将移除fd。</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">int Looper::pollInner(int timeoutMillis) {</font></div><div><font style="font-size: 11px;">#if DEBUG_POLL_AND_WAKE</font></div><div><font style="font-size: 11px;">    ALOGD(&quot;%p ~ pollOnce - waiting: timeoutMillis=%d&quot;, this, timeoutMillis);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Adjust the timeout based on when the next message is due.</font></div><div><font style="font-size: 11px;">    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {</font></div><div><font style="font-size: 11px;">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</font></div><div><font style="font-size: 11px;">        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);</font></div><div><font style="font-size: 11px;">        if (messageTimeoutMillis &gt;= 0</font></div><div><font style="font-size: 11px;">                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {</font></div><div><font style="font-size: 11px;">            timeoutMillis = messageTimeoutMillis;</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">#if DEBUG_POLL_AND_WAKE</font></div><div><font style="font-size: 11px;">        ALOGD(&quot;%p ~ pollOnce - next message in %&quot; PRId64 &quot;ns, adjusted timeout: timeoutMillis=%d&quot;,</font></div><div><font style="font-size: 11px;">                this, mNextMessageUptime - now, timeoutMillis);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Poll.</font></div><div><font style="font-size: 11px;">    int result = POLL_WAKE;</font></div><div><font style="font-size: 11px;">    mResponses.clear();</font></div><div><font style="font-size: 11px;">    mResponseIndex = 0;</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // We are about to idle.</font></div><div><font style="font-size: 11px;">    mPolling = true;</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</font></div><div><font style="font-size: 11px;">    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // No longer idling.</font></div><div><font style="font-size: 11px;">    mPolling = false;</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Acquire lock.</font></div><div><font style="font-size: 11px;">    mLock.lock();</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Rebuild epoll set if needed.</font></div><div><font style="font-size: 11px;">    if (mEpollRebuildRequired) {</font></div><div><font style="font-size: 11px;">        mEpollRebuildRequired = false;</font></div><div><font style="font-size: 11px;">        rebuildEpollLocked();</font></div><div><font style="font-size: 11px;">        goto Done;</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Check for poll error.</font></div><div><font style="font-size: 11px;">    if (eventCount &lt; 0) {</font></div><div><font style="font-size: 11px;">        if (errno == EINTR) {</font></div><div><font style="font-size: 11px;">            goto Done;</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">        ALOGW(&quot;Poll failed with an unexpected error: %s&quot;, strerror(errno));</font></div><div><font style="font-size: 11px;">        result = POLL_ERROR;</font></div><div><font style="font-size: 11px;">        goto Done;</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Check for poll timeout.</font></div><div><font style="font-size: 11px;">    if (eventCount == 0) {</font></div><div><font style="font-size: 11px;">#if DEBUG_POLL_AND_WAKE</font></div><div><font style="font-size: 11px;">        ALOGD(&quot;%p ~ pollOnce - timeout&quot;, this);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;">        result = POLL_TIMEOUT;</font></div><div><font style="font-size: 11px;">        goto Done;</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Handle all events.</font></div><div><font style="font-size: 11px;">#if DEBUG_POLL_AND_WAKE</font></div><div><font style="font-size: 11px;">    ALOGD(&quot;%p ~ pollOnce - handling events from %d fds&quot;, this, eventCount);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    for (int i = 0; i &lt; eventCount; i++) {</font></div><div><font style="font-size: 11px;">        int fd = eventItems[i].data.fd;</font></div><div><font style="font-size: 11px;">        uint32_t epollEvents = eventItems[i].events;</font></div><div><font style="font-size: 11px;">        if (fd == mWakeEventFd) {</font></div><div><font style="font-size: 11px;">            if (epollEvents &amp; EPOLLIN) {</font></div><div><font style="font-size: 11px;">                awoken();</font></div><div><font style="font-size: 11px;">            } else {</font></div><div><font style="font-size: 11px;">                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;, epollEvents);</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;">        } else {</font></div><div><font style="font-size: 11px;">            ssize_t requestIndex = mRequests.indexOfKey(fd);</font></div><div><font style="font-size: 11px;">            if (requestIndex &gt;= 0) {</font></div><div><font style="font-size: 11px;">                int events = 0;</font></div><div><font style="font-size: 11px;">                if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</font></div><div><font style="font-size: 11px;">                if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</font></div><div><font style="font-size: 11px;">                if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</font></div><div><font style="font-size: 11px;">                if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</font></div><div><font style="font-size: 11px;">                pushResponse(events, mRequests.valueAt(requestIndex));</font></div><div><font style="font-size: 11px;">            } else {</font></div><div><font style="font-size: 11px;">                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;</font></div><div><font style="font-size: 11px;">                        &quot;no longer registered.&quot;, epollEvents, fd);</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;">Done: ;</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Invoke pending message callbacks.</font></div><div><font style="font-size: 11px;">    mNextMessageUptime = LLONG_MAX;</font></div><div><font style="font-size: 11px;">    while (mMessageEnvelopes.size() != 0) {</font></div><div><font style="font-size: 11px;">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</font></div><div><font style="font-size: 11px;">        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);</font></div><div><font style="font-size: 11px;">        if (messageEnvelope.uptime &lt;= now) {</font></div><div><font style="font-size: 11px;">            // Remove the envelope from the list.</font></div><div><font style="font-size: 11px;">            // We keep a strong reference to the handler until the call to handleMessage</font></div><div><font style="font-size: 11px;">            // finishes.  Then we drop it so that the handler can be deleted *before*</font></div><div><font style="font-size: 11px;">            // we reacquire our lock.</font></div><div><font style="font-size: 11px;">            { // obtain handler</font></div><div><font style="font-size: 11px;">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</font></div><div><font style="font-size: 11px;">                Message message = messageEnvelope.message;</font></div><div><font style="font-size: 11px;">                mMessageEnvelopes.removeAt(0);</font></div><div><font style="font-size: 11px;">                mSendingMessage = true;</font></div><div><font style="font-size: 11px;">                mLock.unlock();</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</font></div><div><font style="font-size: 11px;">                ALOGD(&quot;%p ~ pollOnce - sending message: handler=%p, what=%d&quot;,</font></div><div><font style="font-size: 11px;">                        this, handler.get(), message.what);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;">                handler-&gt;handleMessage(message);</font></div><div><font style="font-size: 11px;">            } // release handler</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">            mLock.lock();</font></div><div><font style="font-size: 11px;">            mSendingMessage = false;</font></div><div><font style="font-size: 11px;">            result = POLL_CALLBACK;</font></div><div><font style="font-size: 11px;">        } else {</font></div><div><font style="font-size: 11px;">            // The last message left at the head of the queue determines the next wakeup time.</font></div><div><font style="font-size: 11px;">            mNextMessageUptime = messageEnvelope.uptime;</font></div><div><font style="font-size: 11px;">            break;</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Release lock.</font></div><div><font style="font-size: 11px;">    mLock.unlock();</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Invoke all response callbacks.</font></div><div><font style="font-size: 11px;">    for (size_t i = 0; i &lt; mResponses.size(); i++) {</font></div><div><font style="font-size: 11px;">        Response&amp; response = mResponses.editItemAt(i);</font></div><div><font style="font-size: 11px;">        if (response.request.ident == POLL_CALLBACK) {</font></div><div><font style="font-size: 11px;">            int fd = response.request.fd;</font></div><div><font style="font-size: 11px;">            int events = response.events;</font></div><div><font style="font-size: 11px;">            void* data = response.request.data;</font></div><div><font style="font-size: 11px;">#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</font></div><div><font style="font-size: 11px;">            ALOGD(&quot;%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p&quot;,</font></div><div><font style="font-size: 11px;">                    this, response.request.callback.get(), fd, events, data);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;">            // Invoke the callback.  Note that the file descriptor may be closed by</font></div><div><font style="font-size: 11px;">            // the callback (and potentially even reused) before the function returns so</font></div><div><font style="font-size: 11px;">            // we need to be a little careful when removing the file descriptor afterwards.</font></div><div><font style="font-size: 11px;">            int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</font></div><div><font style="font-size: 11px;">            if (callbackResult == 0) {</font></div><div><font style="font-size: 11px;">                removeFd(fd, response.request.seq);</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">            // Clear the callback reference in the response structure promptly because we</font></div><div><font style="font-size: 11px;">            // will not clear the response vector itself until the next poll.</font></div><div><font style="font-size: 11px;">            response.request.callback.clear();</font></div><div><font style="font-size: 11px;">            result = POLL_CALLBACK;</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;">    return result;</font></div><div><font style="font-size: 11px;">}</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">Looper::pollAll，分以下两种情况</font></div><div><font style="font-size: 11px;">1.没有设置超时时间，循环调用pollOnce接口，会将所有的Callback和Event都清空，其他情况都直接返回了;</font></div><div><font style="font-size: 11px;">2.设置了超时时间，循环调用pollOnce接口，也会所有的Callback和Event都清空，其他情况直接返回，但是这里还判断是否超时了，超时了就返回超时;</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">int Looper::pollAll(int timeoutMillis, int* outFd, int* outEvents, void** outData) {</font></div><div><font style="font-size: 11px;">    if (timeoutMillis &lt;= 0) {</font></div><div><font style="font-size: 11px;">        int result;</font></div><div><font style="font-size: 11px;">        do {</font></div><div><font style="font-size: 11px;">            result = pollOnce(timeoutMillis, outFd, outEvents, outData);</font></div><div><font style="font-size: 11px;">        } while (result == POLL_CALLBACK);</font></div><div><font style="font-size: 11px;">        return result;</font></div><div><font style="font-size: 11px;">    } else {</font></div><div><font style="font-size: 11px;">        nsecs_t endTime = systemTime(SYSTEM_TIME_MONOTONIC)</font></div><div><font style="font-size: 11px;">                + milliseconds_to_nanoseconds(timeoutMillis);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        for (;;) {</font></div><div><font style="font-size: 11px;">            int result = pollOnce(timeoutMillis, outFd, outEvents, outData);</font></div><div><font style="font-size: 11px;">            if (result != POLL_CALLBACK) {</font></div><div><font style="font-size: 11px;">                return result;</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</font></div><div><font style="font-size: 11px;">            timeoutMillis = toMillisecondTimeoutDelay(now, endTime);</font></div><div><font style="font-size: 11px;">            if (timeoutMillis == 0) {</font></div><div><font style="font-size: 11px;">                return POLL_TIMEOUT;</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;">}</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">发送消息接口，sendMessage、sendMessageAtTime和sendMessageDelayed都会将Message和MessageHandler放到MessageEnvelope队列中去，通过该消息需要处理的时间，判断是否要放到队列头部，</font></div><div><font style="font-size: 11px;">加入在队列头部，那么就唤醒epoll_wait阻塞的线程，假如正在发送消息，那么就等下一次唤醒。</font></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">void Looper::sendMessage(const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) {</font></div><div><font style="font-size: 11px;">    nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</font></div><div><font style="font-size: 11px;">    sendMessageAtTime(now, handler, message);</font></div><div><font style="font-size: 11px;">}</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">void Looper::sendMessageDelayed(nsecs_t uptimeDelay, const sp&lt;MessageHandler&gt;&amp; handler,</font></div><div><font style="font-size: 11px;">        const Message&amp; message) {</font></div><div><font style="font-size: 11px;">    nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</font></div><div><font style="font-size: 11px;">    sendMessageAtTime(now + uptimeDelay, handler, message);</font></div><div><font style="font-size: 11px;">}</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler,</font></div><div><font style="font-size: 11px;">        const Message&amp; message) {</font></div><div><font style="font-size: 11px;">#if DEBUG_CALLBACKS</font></div><div><font style="font-size: 11px;">    ALOGD(&quot;%p ~ sendMessageAtTime - uptime=%&quot; PRId64 &quot;, handler=%p, what=%d&quot;,</font></div><div><font style="font-size: 11px;">            this, uptime, handler.get(), message.what);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    size_t i = 0;</font></div><div><font style="font-size: 11px;">    { // acquire lock</font></div><div><font style="font-size: 11px;">        AutoMutex _l(mLock);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        size_t messageCount = mMessageEnvelopes.size();</font></div><div><font style="font-size: 11px;">        while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) {</font></div><div><font style="font-size: 11px;">            i += 1;</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        MessageEnvelope messageEnvelope(uptime, handler, message);</font></div><div><font style="font-size: 11px;">        mMessageEnvelopes.insertAt(messageEnvelope, i, 1);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        // Optimization: If the Looper is currently sending a message, then we can skip</font></div><div><font style="font-size: 11px;">        // the call to wake() because the next thing the Looper will do after processing</font></div><div><font style="font-size: 11px;">        // messages is to decide when the next wakeup time should be.  In fact, it does</font></div><div><font style="font-size: 11px;">        // not even matter whether this code is running on the Looper thread.</font></div><div><font style="font-size: 11px;">        if (mSendingMessage) {</font></div><div><font style="font-size: 11px;">            return;</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">    } // release lock</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    // Wake the poll loop only when we enqueue a new message at the head.</font></div><div><font style="font-size: 11px;">    if (i == 0) {</font></div><div><font style="font-size: 11px;">        wake();</font></div><div><font style="font-size: 11px;">    }</font></div><div><font style="font-size: 11px;">}</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">移除Message，通过handler或者handler和what来判断消息队列中是否存在消息</font></div><div><span style="color: rgb(255, 38, 0);"><font style="font-size: 11px;">问题:操作mMessageEvelopes队列并没有调用mLock.lock()和mLock.unLock()，这样会不会有同步的问题？</font></span></div><div><span style="color: rgb(255, 38, 0);"><font style="font-size: 11px;">答：其实是加了锁的了，AutoMutex _l(mLock);这个在函数开始时声明，那么就开始加锁，结束时会自动解锁，或者在两个大括号{开始前声明加锁，结束时就解锁}</font></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">/* </font></div><div><font style="font-size: 11px;">* Automatic mutex.  Declare one of these at the top of a function. </font></div><div><font style="font-size: 11px;">* When the function returns, it will go out of scope, and release the </font></div><div><font style="font-size: 11px;">* mutex. </font></div><div><font style="font-size: 11px;">*/ </font></div><div><font style="font-size: 11px;">typedef Mutex::Autolock AutoMutex;</font></div><div><font style="font-size: 11px;"><br/></font></div><div> </div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">Autolock是Mutex的内嵌类（Java叫内部类），</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">// Manages the mutex automatically. It'll be locked when Autolock is </font></div><div><font style="font-size: 11px;">// constructed and released when Autolock goes out of scope. </font></div><div><font style="font-size: 11px;">class Autolock { </font></div><div><font style="font-size: 11px;">public: </font></div><div><font style="font-size: 11px;">    inline Autolock(Mutex&amp; mutex) : mLock(mutex)  { mLock.lock(); } </font></div><div><font style="font-size: 11px;">    inline Autolock(Mutex* mutex) : mLock(*mutex) { mLock.lock(); } </font></div><div><font style="font-size: 11px;">    inline ~Autolock() { mLock.unlock(); } </font></div><div><font style="font-size: 11px;">private: </font></div><div><font style="font-size: 11px;">    Mutex&amp; mLock; </font></div><div><font style="font-size: 11px;">};</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 11px;">void Looper::removeMessages(const sp&lt;MessageHandler&gt;&amp; handler) {</font></div><div><font style="font-size: 11px;">#if DEBUG_CALLBACKS</font></div><div><font style="font-size: 11px;">    ALOGD(&quot;%p ~ removeMessages - handler=%p&quot;, this, handler.get());</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    { // acquire lock</font></div><div><font style="font-size: 11px;">        AutoMutex _l(mLock);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        for (size_t i = mMessageEnvelopes.size(); i != 0; ) {</font></div><div><font style="font-size: 11px;">            const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(--i);</font></div><div><font style="font-size: 11px;">            if (messageEnvelope.handler == handler) {</font></div><div><font style="font-size: 11px;">                mMessageEnvelopes.removeAt(i);</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">    } // release lock</font></div><div><font style="font-size: 11px;">}</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">void Looper::removeMessages(const sp&lt;MessageHandler&gt;&amp; handler, int what) {</font></div><div><font style="font-size: 11px;">#if DEBUG_CALLBACKS</font></div><div><font style="font-size: 11px;">    ALOGD(&quot;%p ~ removeMessages - handler=%p, what=%d&quot;, this, handler.get(), what);</font></div><div><font style="font-size: 11px;">#endif</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">    { // acquire lock</font></div><div><font style="font-size: 11px;">        AutoMutex _l(mLock);</font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;">        for (size_t i = mMessageEnvelopes.size(); i != 0; ) {</font></div><div><font style="font-size: 11px;">            const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(--i);</font></div><div><font style="font-size: 11px;">            if (messageEnvelope.handler == handler</font></div><div><font style="font-size: 11px;">                    &amp;&amp; messageEnvelope.message.what == what) {</font></div><div><font style="font-size: 11px;">                mMessageEnvelopes.removeAt(i);</font></div><div><font style="font-size: 11px;">            }</font></div><div><font style="font-size: 11px;">        }</font></div><div><font style="font-size: 11px;">    } // release lock</font></div><div><font style="font-size: 11px;">}</font></div></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div><font style="font-size: 11px;"><br/></font></div><div><a href="http://blog.csdn.net/chwan_gogogo/article/details/46953549"><font style="font-size: 11px;">http://blog.csdn.net/chwan_gogogo/article/details/46953549</font></a></div><div><a href="http://blog.csdn.net/chwan_gogogo/article/details/46953563"><font style="font-size: 11px;">http://blog.csdn.net/chwan_gogogo/article/details/46953563</font></a></div></en-note>
]]></content><created>20170821T062938Z</created><updated>20170831T065704Z</updated><note-attributes><latitude>22.53659004899187</latitude><longitude>114.0505343937581</longitude><altitude>13.76594161987305</altitude><author>1009439210@qq.com</author><source>desktop.mac</source><reminder-order>0</reminder-order></note-attributes></note>
</en-export>
