<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export3.dtd">
<en-export export-date="20171124T092250Z" application="Evernote" version="Evernote Mac 6.12.2 (455489)">
<note><title>Android源码知识补充站-Handler的分析</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div>Handler线程间通信机制</div><div><br/></div><div>线程间通信机制主要涉及一下的几个对象</div><div>Looper.java&nbsp;</div><div>Handler.java</div><div>Message.java</div><div>MessageQueue.java</div><div>android_os_MessageQueue.cpp</div><div>/sys/utils/looper.cpp</div><div>/sys/utils/looper.h</div><div><br/></div><div>Looper.java</div><div>这个类是线程间消息处理核心，从使用上分析</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class LooperThread extends Thread{</div><div>&nbsp; &nbsp; &nbsp;public Handler mHandler;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp;public void run(){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Looper.prepare();</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mHandler = new Handler(){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void handleMessage(Message msg){</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Looper.loop();</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>}</div></div><div><br/></div><div>首先Looper.prepare();是Looper的初始化，初始化了两个对象MessageQueue对象和Thread对象，mThread是当前的线程，MessageQueue是消息队列，并传递参数设置当前Looper是否允许退出，当当前线程是主线程的时候，不允许退出。而创建对象MessageQueue的时候，除了传递参数mQuitAllowed以外，底层初始化了NativeMessageQueue，并将该对象传递给mPtr，并把该Looper对象放到ThreadLocal对象中，为下一步做准备</div><div>&nbsp;</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; public static void prepare() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; prepare(true);</div><div>&nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; private static void prepare(boolean quitAllowed) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (sThreadLocal.get() != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; sThreadLocal.set(new Looper(quitAllowed));</div><div>&nbsp; &nbsp; }</div></div><div>&nbsp;&nbsp;</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; private Looper(boolean quitAllowed) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mQueue = new MessageQueue(quitAllowed);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mThread = Thread.currentThread();</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; &nbsp; MessageQueue(boolean quitAllowed) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mQuitAllowed = quitAllowed;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mPtr = nativeInit();</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {</div><div>&nbsp; &nbsp; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</div><div>&nbsp; &nbsp; if (!nativeMessageQueue) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return 0;</div><div>&nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; nativeMessageQueue-&gt;incStrong(env);</div><div>&nbsp; &nbsp; return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</div><div>}</div></div><div><br/></div><div>创建完Looper后，需要再创建一个Handler，从上面的Handler来看并没有设置Looper的，而其实内部通过Looper.myLooper()来获取到当前的线程的Looper，和设置mQueue，mCallback，mAsynchronous，设置了mCallback将不会调用handleMessage(),mAsynchronous是设置该消息是否是异步的调用，设置了的话，会在下一次唤醒线程时回调。</div><div>&nbsp;&nbsp;</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; public Handler(Callback callback, boolean async) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (FIND_POTENTIAL_LEAKS) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final Class&lt;? extends Handler&gt; klass = getClass();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; klass.getCanonicalName());</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; mLooper = Looper.myLooper();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (mLooper == null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new RuntimeException(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mQueue = mLooper.mQueue;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mCallback = callback;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mAsynchronous = async;</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>最后Looper.loop(),这里会不停的循环MessageQueue，将消息从消息队列中取出，并通过Message中的handler回调dispatchMessage(msg)。而核心部分是MessageQueue.next()取消息里面主要分一下几步</div><div>1.nativePollOnce(ptr, nextPollTimeoutMillis);会根据nextPollTimeOut来判断要阻塞几秒，0立即返回，-1永久阻塞，n是阻塞n秒;</div><div>2.取出MessageQueue队列中的有handler的Message，判断当前消息是否要返回，否则将计算出等待的时间。</div><div>3.假如队列的头消息的target为空，则找到当前不异步的消息,异步的消息要保证某些动作完成前他们才能够被处理，否则将忽略，比如View.invalidate;</div><div>4.如果取出的消息不为空，那么判断消息处理的时间，还没到就算出epoll需要等待的时间，否则将此消息返回, 取出的消息为空的话，消息队列中没消息，将永久阻塞;</div><div>5.判断是否正在退出，是的话，就退出并消息NativeMessageQueue对象;</div><div>6.mIdleHandlers中是否要对象，没有的话，就进入等待，有的话就执行keep = idler.queueIdle();假如keep为true的话不会移除，每次分发消息的时候都会执行该函数;</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; &nbsp; Message next() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // Return here if the message loop has already quit and been disposed.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // This can happen if the application tries to restart a looper after quit</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // which is not supported.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; final long ptr = mPtr;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (ptr == 0) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; int pendingIdleHandlerCount = -1; // -1 only during first iteration</div><div>&nbsp; &nbsp; &nbsp; &nbsp; int nextPollTimeoutMillis = 0;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; for (;;) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nextPollTimeoutMillis != 0) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Binder.flushPendingCommands();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nativePollOnce(ptr, nextPollTimeoutMillis);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized (this) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Try to retrieve the next message.&nbsp; Return if found.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final long now = SystemClock.uptimeMillis();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message prevMsg = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message msg = mMessages;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (msg != null &amp;&amp; msg.target == null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Stalled by a barrier.&nbsp; Find the next asynchronous message in the queue.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevMsg = msg;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg = msg.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (msg != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (now &lt; msg.when) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Next message is not ready.&nbsp; Set a timeout to wake up when it is ready.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Got a message.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mBlocked = false;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prevMsg != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevMsg.next = msg.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mMessages = msg.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.next = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (false) Log.v(&quot;MessageQueue&quot;, &quot;Returning message: &quot; + msg);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return msg;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // No more messages.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextPollTimeoutMillis = -1;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Process the quit message now that all pending messages have been handled.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mQuitting) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dispose();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // If first time idle, then get the number of idlers to run.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Idle handles only run if the queue is empty or if the first message</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // in the queue (possibly a barrier) is due to be handled in the future.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pendingIdleHandlerCount &lt; 0</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingIdleHandlerCount = mIdleHandlers.size();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pendingIdleHandlerCount &lt;= 0) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // No idle handlers to run.&nbsp; Loop and wait some more.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mBlocked = true;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mPendingIdleHandlers == null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Run the idle handlers.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // We only ever reach this code block during the first iteration.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final IdleHandler idler = mPendingIdleHandlers[i];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPendingIdleHandlers[i] = null; // release the reference to the handler</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean keep = false;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keep = idler.queueIdle();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (Throwable t) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Log.wtf(&quot;MessageQueue&quot;, &quot;IdleHandler threw exception&quot;, t);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!keep) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized (this) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mIdleHandlers.remove(idler);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Reset the idle handler count to 0 so we do not run them again.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingIdleHandlerCount = 0;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // While calling an idle handler, a new message could have been delivered</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // so go back and look again for a pending message without waiting.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextPollTimeoutMillis = 0;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>先看下发送消息，Handler.sendMessage(Message msg);等接口都会调用到sendMessageAtTime(Message msg, long uptimeMillis);而上函数其实是调用enqueueMessage函数，假如当前是异步处理消息的话，所有的消息都是isAsynchronous的，然后通过调用MessageQueue.enqueueMessage(msg, uptimeMilles);</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; &nbsp; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; msg.target = this;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (mAsynchronous) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.setAsynchronous(true);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return queue.enqueueMessage(msg, uptimeMillis);</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>再看创建消息，可以直接new一个，或者通过obtain来创建消息，建议直接用Message.obtain来创建消息。</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; &nbsp; public static Message obtain() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; synchronized (sPoolSync) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (sPool != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message m = sPool;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sPool = m.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m.next = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m.flags = 0; // clear in-use flag</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sPoolSize--;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return m;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return new Message();</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>而消息通过MessageQueue.enqueueMessage()放到mMessages消息队列中的合适的位置，并且判断是否要唤醒epoll来处理消息，假如是isAsynchronous的消息的话，将不会唤醒epoll。</div><div>&nbsp;</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; boolean enqueueMessage(Message msg, long when) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (msg.target == null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (msg.isInUse()) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; synchronized (this) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mQuitting) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IllegalStateException e = new IllegalStateException(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Log.w(&quot;MessageQueue&quot;, e.getMessage(), e);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.recycle();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.markInUse();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.when = when;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message p = mMessages;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean needWake;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (p == null || when == 0 || when &lt; p.when) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // New head, wake up the event queue if blocked.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.next = p;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mMessages = msg;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needWake = mBlocked;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Inserted within the middle of the queue.&nbsp; Usually we don&apos;t have to wake</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // up the event queue unless there is a barrier at the head of the queue</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // and the message is the earliest asynchronous message in the queue.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message prev;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (;;) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev = p;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = p.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (p == null || when &lt; p.when) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (needWake &amp;&amp; p.isAsynchronous()) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needWake = false;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg.next = p; // invariant: p == prev.next</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev.next = msg;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // We can assume mPtr != 0 because mQuitting is false.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (needWake) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nativeWake(mPtr);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return true;</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>再看移除消息，通过Handler.removeMessages()，其实是调用到了MessageQueue.removeMessages(),将消息移除并回收消息。</div><div>&nbsp;</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; void removeMessages(Handler h, int what, Object object) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (h == null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; synchronized (this) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message p = mMessages;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Remove all messages at front.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; (object == null || p.obj == object)) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message n = p.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mMessages = n;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.recycleUnchecked();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = n;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br/></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Remove all messages after front.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (p != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message n = p.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n.target == h &amp;&amp; n.what == what</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (object == null || n.obj == object)) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message nn = n.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n.recycleUnchecked();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.next = nn;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = n;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>最后看Looper的退出，Looper.quit(boolean),来退出Looper，方式有两种一种是quitSafe，另一种是quit直接退出</div><div>quitSafe先判断队列头部消息是当前的消息的话，那么和直接退出方式是一样的，</div><div>否则将找到事件的时间大于当前时间的，并将大于当前事件的事件回收。</div><div>&nbsp;</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; private void removeAllFutureMessagesLocked() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; final long now = SystemClock.uptimeMillis();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Message p = mMessages;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (p != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (p.when &gt; now) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removeAllMessagesLocked();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message n;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (;;) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = p.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n == null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n.when &gt; now) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = n;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.next = null;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = n;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = p.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.recycleUnchecked();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } while (n != null);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div></div><div><br/></div><div>quit直接退出，是将当前队列所有的消息直接回收。</div><div>&nbsp;</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; private void removeAllMessagesLocked() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Message p = mMessages;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; while (p != null) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message n = p.next;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.recycleUnchecked();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = n;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mMessages = null;</div><div>&nbsp; &nbsp; }</div></div><div>根据官方注释的解析是已经被handle的消息遗留在消息队列中，直接将它们回收有可能会造成消息为空，这样的话，可能造成不同步，所以quitSafe保留这些被分发的消息，而不会造成程序异常。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&nbsp; &nbsp; /**</div><div>&nbsp; &nbsp; &nbsp;* Quits the looper safely.</div><div>&nbsp; &nbsp; &nbsp;* &lt;p&gt;</div><div>&nbsp; &nbsp; &nbsp;* Causes the {@link #loop} method to terminate as soon as all remaining messages</div><div>&nbsp; &nbsp; &nbsp;* in the message queue that are already due to be delivered have been handled.</div><div>&nbsp; &nbsp; &nbsp;* However pending delayed messages with due times in the future will not be</div><div>&nbsp; &nbsp; &nbsp;* delivered before the loop terminates.</div><div>&nbsp; &nbsp; &nbsp;* &lt;/p&gt;&lt;p&gt;</div><div>&nbsp; &nbsp; &nbsp;* Any attempt to post messages to the queue after the looper is asked to quit will fail.</div><div>&nbsp; &nbsp; &nbsp;* For example, the {@link Handler#sendMessage(Message)} method will return false.</div><div>&nbsp; &nbsp; &nbsp;* &lt;/p&gt;</div><div>&nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; public void quitSafely() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; mQueue.quit(true);</div><div>&nbsp; &nbsp; }</div></div><div><br/></div></en-note>]]></content><created>20170901T135023Z</created><updated>20170903T141332Z</updated><note-attributes><author>1009439210@qq.com</author><source>desktop.win</source><source-application>evernote.win32</source-application><reminder-order>0</reminder-order></note-attributes></note>
</en-export>
