<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export3.dtd">
<en-export export-date="20171124T092400Z" application="Evernote" version="Evernote Mac 6.12.2 (455489)">
<note><title>Android源码阅读知识补充站-监控文件系统inotify</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div>Inotify是用来监视文件系统事件的机制，在linux2.6.13内核中引入。该机制可以用来监视文件和目录，当文件或目录发送改变时，，内核会将文件或目录的变化发送给inotify文件描述符，在应用层只需调用read()就可以读取这些事件，非常方便。更好的是，inotify文件描述符还可以使用select、poll、epoll这些监控，当有事件发生时，inotify文件描述符会可读。</div><div><br/></div><div>1.接口介绍</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>1)inotify_init()</div><div><br/></div><div>定义如下：</div><div>#include &lt;sys/inotify.h&gt;</div><div><br/></div><div>int inotify_init(void);</div><div>int inotify_init1(int flags);</div><div><br/></div><div>inotify_init()用来初始化一个新的inotify实例，并返回一个文件描述符，这个文件描述符在inotify_add_watch()中会用到，发生的事件也是从这个描述中读取的。</div><div><br/></div><div>除了这个接口外，还有一个相同功能的inotify_init1()。这个接口中多了一个参数flags，用来初始化设置inotify文件描述符的属性。flags中可以设置的标志有两个：IN_NONBLOCK和IN_CLOEXEC。这两个标志不难理解，前一个是用来将inotify文件描述设置为非阻塞状态，后者是设置close-on-exec(FD_CLOEXEC)标志。通过使用这两个标志就避免在创建inotify文件描述后，在调用fcntl()的消耗了。</div><div><br/></div><div>2)inotify_add_watch();</div><div><br/></div><div>定义如下：</div><div>#include &lt;sys/inotify.h&gt;</div><div><br/></div><div>int inotify_add_watch(int fd, const char *pathname, uint32_t mask);</div><div>其中fd是inotify文件描述符，inotify_init()的返回值；pathname是要监听文件的路径，mask是表示要监听什么事件</div><div><br/></div><div>inotify_add_watch()用于将要监听的文件或者目录，返回值是一个inotify标识，这和init返回的标识不一样，watch返回值用于判断返回事件属于哪个监听文件（后面的inotify_event结构是会看到）以及用于移除监听文件时使用。</div><div><br/></div><div>3)inotify_rm_watch()</div><div><br/></div><div>定义如下：</div><div>&nbsp; &nbsp; &nbsp;#include &lt;sys/inotify.h&gt;</div><div>&nbsp; &nbsp; &nbsp;int inotify_rm_watch(int fd, unint32_t wd);</div><div><br/></div><div>inotify_rm_watch()用来移除对某个文件的监听，其中fd是inotify文件描述符，由inotify_init()返回，wd是inotify标识，由inotify_add_watch()返回。</div><div><br/></div><div>2.结构及事件介绍</div><div>&nbsp; &nbsp; &nbsp;当有事件发生时，notify文件描述符会变为可读，调用read()可以读取变化发送的事件，事件的描述结构为inotify_event结构体定义如下：</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>struct inotify_event{</div><div>&nbsp; &nbsp; &nbsp;int wd; /*Watch descriptor*/</div><div>&nbsp; &nbsp; &nbsp;uint32_t mask; /*Mask of events*/</div><div>&nbsp; &nbsp; &nbsp;uint32_t cookie; /*Unique cookie associating related events(for rename(2))*/</div><div>&nbsp; &nbsp; &nbsp;uint32_t len; /*Size of name field*/</div><div>&nbsp; &nbsp; &nbsp;char name[]; /*Optional null-terminated name*/</div><div>}</div></div><div><br/></div><div>其中wd是inotify标识符，inotify_add_watch()的返回值;mask就是发生的事件掩码;cookie这个好像只在rename中使用，这里不关心;len是name的长度；包括空字符，name是引发事件的文件名，不包括路径。</div><div><br/></div><div>首先说明inotify_event的长度问题，从定义中可以看出name的长度是可变的，所以一个事件对于的长度应该是sizeof(struct inotify_event)+len。</div><div><br/></div><div>还有一个问题要特别说明，在read()的时候如果指定的缓冲区长度小于一个事件的长度(即sizeof(struct inotify_event) + len),这时候内核会返回EINVAL错误，这个错误是在inotify_read()调用get_one_event()函数中返回的，代码如下：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>static struct fsnotify_event *get_one_event(struct fsnotify_group *group , size_t count){</div><div>&nbsp; &nbsp; &nbsp;size_t event_size = sizeof(struct inotify_event);</div><div>&nbsp; &nbsp; &nbsp;struct fsnotify_event *event;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp;if(fsnotify_notify_queue_is_empty(group))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;</div><div><br/></div><div>&nbsp; &nbsp; &nbsp;event = fsnotify_peek_notify_event(group);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp;if(event-&gt;name_len)</div><div>&nbsp; &nbsp; &nbsp;event_size += roundup(event-&gt;name_len + 1, event_size);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp;if(event_size &gt; count)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ERR_PTR(-EINVAL);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp;/*held the notification_mutex the whole time, so &nbsp; &nbsp; &nbsp;this is the same event we peeked above*/</div><div>&nbsp; &nbsp; &nbsp;fsnotify_remove_notify_event(group);</div><div><br/></div><div>&nbsp; &nbsp; &nbsp;return event;</div><div>}</div></div><div><br/></div><div>所以在调用read从inotify文件描述符读取事件时一定要保证你的缓冲区的大小至少为sizeof(struct inotify_event) + NAME_MAX +1 ,其中NAME_MAX是文件名的最大值，linux下是255；</div><div><br/></div><div>接下来介绍inotify中的事件，及mask的取值。下面的这些宏代表不同的事件，这些值在inotify_add_watch()中的mask参数和inotify_event结构中的mask成员中都可以使用，如下所示：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>IN_ACCESS:文件被访问</div><div><br/></div><div>IN_ATTRIB:元数据被改变，例如权限、时间戳、扩展属性、链接数、UID、GID等</div><div><br/></div><div>IN_CLOSE_WRITE:关闭打开写的文件</div><div><br/></div><div>IN_CLOSE_NOWRITE:和IN_CLOSE_WRITE刚好相反，关闭不是打开写的文件</div><div><br/></div><div>IN_CREATE:这个是用于目录，在监控目录中创建目录或文件是发生</div><div><br/></div><div>IN_DELETE:这个也是用于目录，在监控目录中删除目录或者文件时发生。</div><div><br/></div><div>IN_DELETE_SELF:监控目录或文件本身被删除</div><div><br/></div><div>IN_MODIFY:文件被修改，这种事件会用到inotify_event中的cookie。</div><div><br/></div><div>IN_MOVE_SELF:监控的文件或目录本身被移动</div><div><br/></div><div>IN_MOVE_FROM:从监控的目录中移除文件</div><div><br/></div><div>IN_MOVE_TO:向监控的目录中移入文件</div><div><br/></div><div>IN_OPEN:文件被打开</div><div><br/></div><div>（注：Linux下都已抽象为文件，如果没有特别说明，文件可以指普通文件或目录）</div><div><br/></div><div>下面这些bit位只在调用inotify_add_watch()中用到：</div><div>IN_DONT_FOLLOW:如果监控的文件时一个符号链接，只监控符号链接本身，而不是链接指向的文件</div><div><br/></div><div>IN_MASK_ADD:对已监控的文件增加要监控的事件（ 不是替换原来的掩码）</div><div><br/></div><div>IN_ONESHOT:只监控指定的文件一次，事件发生后从监控列表移除。</div><div><br/></div><div>IN_ONLYDIR:如果监控的是一个目录，只监控目录本身（待定）</div><div><br/></div><div>下面这些bit位可能在read()读取到的事件中设置:</div><div><br/></div><div>IN_IGNORED:监控被显式移除（调用inofity_rm_watch()）,或者自动移除（文件被删除或者文件系统被卸载）</div><div><br/></div><div>IN_ISDIR:引发事件的是一个目录</div><div><br/></div><div>IN_Q_OVERFLOW:事件队列溢出（这种情况下inotify_event结构中的wd为-1）</div><div><br/></div><div>IN_UMOUNT:包含监控对象的文件系统被卸载</div></div><div><br/></div><div><br/></div><div>inotify的资源限制可以通过/proc文件系统来修改，涉及的接口有：</div><div>/proc/sys/fs/inotify/max_queued_events:指定每个inotify实例的事件队列的最大长度，即可以缓存的事件个数。</div><div>/proc/sys/fs/inotify/max_user_instances:每个用户可以创建的inotify实例的个数。</div><div>/proc/sys/fs/inotify/max_user_watches:每个用户可以监控的文件上限</div><div><br/></div><div>参考文档</div><div><a href="http://www.linuxidc.com/Linux/2013-03/81017p2.htm">http://www.linuxidc.com/Linux/2013-03/81017p2.htm</a></div><div><a href="http://blog.csdn.net/hepeng597/article/details/7792565">http://blog.csdn.net/hepeng597/article/details/7792565</a></div><div><br/></div></en-note>]]></content><created>20170819T142903Z</created><updated>20170820T015252Z</updated><note-attributes><author>1009439210@qq.com</author><source>desktop.win</source><source-application>evernote.win32</source-application><reminder-order>0</reminder-order></note-attributes></note>
</en-export>
