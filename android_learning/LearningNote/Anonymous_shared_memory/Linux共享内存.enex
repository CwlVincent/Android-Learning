<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export3.dtd">
<en-export export-date="20180112T082033Z" application="Evernote" version="Evernote Mac 6.12.2 (455489)">
<note><title>Linux共享内存</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">
<en-note><div>1.两个关键函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>    int shmget(key_t key, size_t size, int shmflg);该函数用来创建共享内存</div><div>    void *shmat(int shm_id, const void *shm_addr, int shmflg);要想访问共享内存，必须将其映射到当前进程的地址空间</div></div><div><span><span><span>    </span><br/></span></span></div><div><span><span><span><span>    key_t是共享内存的唯一标识，可以说，Linux的共享内存其实是有名的共享内存，而名字就是key，具体用法如下:</span><br/></span></span></span></div><div>读取进程</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>int main()</div><div>{</div><div>    void *shm = NULL;//分配的共享内存的原始首地址</div><div>    struct shared_use_st *shared;//指向shm</div><div>    int shmid;//共享内存标识符</div><div>    //创建共享内存</div><div>    shmid = shmget((key_t)12345,sizeof(struct shared_use_st), 0666|IPC_CREAT);</div><div>    //将共享内存映射到当前进程的地址空间</div><div>    shm = shmat(shmid, 0, 0);</div><div>    //设置共享内存</div><div>    shared = (struct shared_use_str*)shm;</div><div>    shared-&gt;written = 0;</div><div>    //访问共享内存</div><div>    while(1){</div><div>        if(shared-&gt;written != 0){</div><div>            printf(&quot;You wrote:%s&quot;, shared-&gt;text);</div><div>            if(strncmp(shared-&gt;text, &quot;end&quot;, 3)==0）</div><div>                break;</div><div>        }</div><div>    }</div><div>    //把共享内存从当前进程中分离</div><div>    if(shmdt(shm) == -1){}</div><div>    //删除共享内存</div><div>    if(shmctl(shmid, IPC_RMID, 0) == -1)}{}</div><div>    exit(EXIT_SUCCESS);</div><div>}</div></div><div><br/></div><div>写进程</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><br/></div><div>int main(){</div><div>    void *shm = NULL;</div><div>    struct shared_use_st *shared = NULL;</div><div>    char buffer[BUFSIZ + 1];//用于保存输入的文本</div><div>    int shmid;</div><div>    //创建共享内存</div><div>    shmid = shmget((key_t)12345, sizeof(struct shared_use_st), 0666|IPC_CREAT );</div><div>    //将共享内存连接到当前进程的地址空间</div><div>    shm = shmat(shmid, (void*)0,0);</div><div>    printf(&quot;Memory attached at %X\n&quot;, (int) shm);</div><div>    //设置共享内存</div><div>    shared = (struct shared_use_st*)shm;</div><div>    while(1)//向共享内存中写数据</div><div>    {</div><div>        //数据还没有被读取，则等待数据被读取，不能向共享内存中写入文本</div><div>        while(shared-&gt;written == 1){</div><div>            sleep(1);</div><div>        }</div><div>        //向共享内存中写入数据</div><div>        fgets(buffer, BUFSIZ, stdin);</div><div>        strncpy(shared-&gt;text, buffer, TEXT_SZ);</div><div>        shared-&gt;written = 1;</div><div>        if(strncmp(buffer, &quot;end&quot;, 3) == 0)</div><div>            running = 0;</div><div>    }</div><div>    //把共享内存从当前进程中分离</div><div>    if(shmdt(shm) == -1) {}</div><div>    sleep(2);</div><div>    exit(EXIT_SUCCESS);</div><div>}</div></div><div><br/></div><div><br/></div><div>可以看到，Linux共享内存通信效率非常高，进程间不需要传递数据，便可以直接访问，缺点也很明显，Linux共享内存没有提供同步的机制，在使用时，要借助其他的手段来处理进程间同步。Android本身在核心态是支持System V的功能，但是bionic库删除了glibc的shmget等函数，使得android无法采用shmget的方式实现有名共享内存，当然，它也没想着用那个，Android在此基础上，创建了自己的匿名共享内存方式。</div></en-note>
]]></content><created>20180112T072956Z</created><updated>20180112T075326Z</updated><note-attributes><latitude>22.53658964195226</latitude><longitude>114.050541644998</longitude><altitude>10.63206768035889</altitude><author>雅字杀手</author><source>desktop.mac</source><reminder-order>0</reminder-order></note-attributes></note>
</en-export>
