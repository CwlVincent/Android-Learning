<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export3.dtd">
<en-export export-date="20180111T111648Z" application="Evernote" version="Evernote Mac 6.12.2 (455489)">
<note><title>贯通Android应用层到Linux驱动层</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">
<en-note><div>1.在驱动层定义具体的交互功能，然后参加设备节点与上层交互。</div><div>调用class_register()接口，在/sys/class/目录下创建设备节点。</div><div>调用misc_register()接口，在/dev/目录下创建设备节点。</div><div><br/></div><div>在/dev/目录下创建设备节点的方法</div><div>1.定义file_operations 即ashmem_fops将与用户空间对应的操作函数，凡是用到都是同一个模板的。</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">static const struct file_operations ashmem_fops = {</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .owner = THIS_MODULE,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .open = ashmem_open,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .release = ashmem_release,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .read = ashmem_read,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .llseek = ashmem_llseek,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .mmap = ashmem_mmap,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .unlocked_ioctl = ashmem_ioctl,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#ifdef CONFIG_COMPAT</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .compat_ioctl = compat_ashmem_ioctl,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#endif</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">};</span></div></div><div>用户空间调用了open函数会对应调用到ashmem_open函数</div><div><br/></div><div>2.定义miscdevice设备信息，用于注册misc的设备信息</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">static struct miscdevice ashmem_misc = {</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .minor = MISC_DYNAMIC_MINOR,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .name = &quot;ashmem&quot;,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    .fops = &amp;ashmem_fops,</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">};</span></div></div><div><br/></div><div><br/></div><div>3.定义ashmem_init，并调用device_initcall注册到内核空间中去，即内核启动的时候，会调用这些注册函数。</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">static int __init ashmem_init(void)</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">{</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    int ret;</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    ashmem_area_cachep = kmem_cache_create(&quot;ashmem_area_cache&quot;,</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                           sizeof(struct ashmem_area),</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                           0, 0, NULL);</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    if (unlikely(!ashmem_area_cachep)) {</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        pr_err(&quot;failed to create slab cache\n&quot;);</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        return -ENOMEM;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    }</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    ashmem_range_cachep = kmem_cache_create(&quot;ashmem_range_cache&quot;,</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                        sizeof(struct ashmem_range),</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                        0, 0, NULL);</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    if (unlikely(!ashmem_range_cachep)) {</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        pr_err(&quot;failed to create slab cache\n&quot;);</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        return -ENOMEM;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    }</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    ret = misc_register(&amp;ashmem_misc);</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    if (unlikely(ret)) {</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        pr_err(&quot;failed to register misc device!\n&quot;);</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        return ret;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    }</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    register_shrinker(&amp;ashmem_shrinker);</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    pr_info(&quot;initialized\n&quot;);</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    return 0;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">}</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">device_initcall(ashmem_init);</span></div></div><div><br/></div><div>3.通过调用misc_register将注册misc设备信息，并调用device_create_with_groups函数，再调用device_create_file，创建/dev/ashmem设备文件。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>int misc_register(struct miscdevice * misc)</div><div>{</div><div>    dev_t dev;</div><div>    int err = 0;</div><div>    bool is_dynamic = (misc-&gt;minor == MISC_DYNAMIC_MINOR);</div><div><br/></div><div>    INIT_LIST_HEAD(&amp;misc-&gt;list);</div><div><br/></div><div>    mutex_lock(&amp;misc_mtx);</div><div><br/></div><div>    if (is_dynamic) {</div><div>        int i = find_first_zero_bit(misc_minors, DYNAMIC_MINORS);</div><div>        if (i &gt;= DYNAMIC_MINORS) {</div><div>            err = -EBUSY;</div><div>            goto out;</div><div>        }</div><div>        misc-&gt;minor = DYNAMIC_MINORS - i - 1;</div><div>        set_bit(i, misc_minors);</div><div>    } else {</div><div>        struct miscdevice *c;</div><div><br/></div><div>        list_for_each_entry(c, &amp;misc_list, list) {</div><div>            if (c-&gt;minor == misc-&gt;minor) {</div><div>                err = -EBUSY;</div><div>                goto out;</div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div>    dev = MKDEV(MISC_MAJOR, misc-&gt;minor);</div><div><br/></div><div>    misc-&gt;this_device =</div><div>        device_create_with_groups(misc_class, misc-&gt;parent, dev,</div><div>                      misc, misc-&gt;groups, &quot;%s&quot;, misc-&gt;name);</div><div>    if (IS_ERR(misc-&gt;this_device)) {</div><div>        if (is_dynamic) {</div><div>            int i = DYNAMIC_MINORS - misc-&gt;minor - 1;</div><div><br/></div><div>            if (i &lt; DYNAMIC_MINORS &amp;&amp; i &gt;= 0)</div><div>                clear_bit(i, misc_minors);</div><div>            misc-&gt;minor = MISC_DYNAMIC_MINOR;</div><div>        }</div><div>        err = PTR_ERR(misc-&gt;this_device);</div><div>        goto out;</div><div>    }</div><div><br/></div><div>    /*</div><div>     * Add it to the front, so that later devices can &quot;override&quot;</div><div>     * earlier defaults</div><div>     */</div><div>    list_add(&amp;misc-&gt;list, &amp;misc_list);</div><div> out:</div><div>    mutex_unlock(&amp;misc_mtx);</div><div>    return err;</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>struct device *device_create_with_groups(struct class *class,</div><div>                     struct device *parent, dev_t devt,</div><div>                     void *drvdata,</div><div>                     const struct attribute_group **groups,</div><div>                     const char *fmt, ...)</div><div>{</div><div>    va_list vargs;</div><div>    struct device *dev;</div><div><br/></div><div>    va_start(vargs, fmt);</div><div>    dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,</div><div>                     fmt, vargs);</div><div>    va_end(vargs);</div><div>    return dev;</div><div>}</div><div>EXPORT_SYMBOL_GPL(device_create_with_groups);</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>static struct device *</div><div>device_create_groups_vargs(struct class *class, struct device *parent,</div><div>               dev_t devt, void *drvdata,</div><div>               const struct attribute_group **groups,</div><div>               const char *fmt, va_list args)</div><div>{</div><div>    struct device *dev = NULL;</div><div>    int retval = -ENODEV;</div><div><br/></div><div>    if (class == NULL || IS_ERR(class))</div><div>        goto error;</div><div><br/></div><div>    dev = kzalloc(sizeof(*dev), GFP_KERNEL);</div><div>    if (!dev) {</div><div>        retval = -ENOMEM;</div><div>        goto error;</div><div>    }</div><div><br/></div><div>    device_initialize(dev);</div><div>    dev-&gt;devt = devt;</div><div>    dev-&gt;class = class;</div><div>    dev-&gt;parent = parent;</div><div>    dev-&gt;groups = groups;</div><div>    dev-&gt;release = device_create_release;</div><div>    dev_set_drvdata(dev, drvdata);</div><div><br/></div><div>    retval = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, args);</div><div>    if (retval)</div><div>        goto error;</div><div><br/></div><div>    retval = device_add(dev);</div><div>    if (retval)</div><div>        goto error;</div><div><br/></div><div>    return dev;</div><div><br/></div><div>error:</div><div>    put_device(dev);</div><div>    return ERR_PTR(retval);</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>int device_add(struct device *dev)</div><div>{</div><div>    struct device *parent = NULL;</div><div>    struct kobject *kobj;</div><div>    struct class_interface *class_intf;</div><div>    int error = -EINVAL;</div><div><br/></div><div>    dev = get_device(dev);</div><div>    if (!dev)</div><div>        goto done;</div><div><br/></div><div>    if (!dev-&gt;p) {</div><div>        error = device_private_init(dev);</div><div>        if (error)</div><div>            goto done;</div><div>    }</div><div><br/></div><div>    /*</div><div>     * for statically allocated devices, which should all be converted</div><div>     * some day, we need to initialize the name. We prevent reading back</div><div>     * the name, and force the use of dev_name()</div><div>     */</div><div>    if (dev-&gt;init_name) {</div><div>        dev_set_name(dev, &quot;%s&quot;, dev-&gt;init_name);</div><div>        dev-&gt;init_name = NULL;</div><div>    }</div><div><br/></div><div>    /* subsystems can specify simple device enumeration */</div><div>    if (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</div><div>        dev_set_name(dev, &quot;%s%u&quot;, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</div><div><br/></div><div>    if (!dev_name(dev)) {</div><div>        error = -EINVAL;</div><div>        goto name_error;</div><div>    }</div><div><br/></div><div>    pr_debug(&quot;device: '%s': %s\n&quot;, dev_name(dev), __func__);</div><div><br/></div><div>    parent = get_device(dev-&gt;parent);</div><div>    kobj = get_device_parent(dev, parent);</div><div>    if (kobj)</div><div>        dev-&gt;kobj.parent = kobj;</div><div><br/></div><div>    /* use parent numa_node */</div><div>    if (parent &amp;&amp; (dev_to_node(dev) == NUMA_NO_NODE))</div><div>        set_dev_node(dev, dev_to_node(parent));</div><div><br/></div><div>    /* first, register with generic layer. */</div><div>    /* we require the name to be set before, and pass NULL */</div><div>    error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);</div><div>    if (error)</div><div>        goto Error;</div><div><br/></div><div>    /* notify platform of device entry */</div><div>    if (platform_notify)</div><div>        platform_notify(dev);</div><div><br/></div><div>    error = device_create_file(dev, &amp;dev_attr_uevent);</div><div>    if (error)</div><div>        goto attrError;</div><div><br/></div><div>    error = device_add_class_symlinks(dev);</div><div>    if (error)</div><div>        goto SymlinkError;</div><div>    error = device_add_attrs(dev);</div><div>    if (error)</div><div>        goto AttrsError;</div><div>    error = bus_add_device(dev);</div><div>    if (error)</div><div>        goto BusError;</div><div>    error = dpm_sysfs_add(dev);</div><div>    if (error)</div><div>        goto DPMError;</div><div>    device_pm_add(dev);</div><div><br/></div><div>    if (MAJOR(dev-&gt;devt)) {</div><div>        error = device_create_file(dev, &amp;dev_attr_dev);</div><div>        if (error)</div><div>            goto DevAttrError;</div><div><br/></div><div>        error = device_create_sys_dev_entry(dev);</div><div>        if (error)</div><div>            goto SysEntryError;</div><div><br/></div><div>        devtmpfs_create_node(dev);</div><div>    }</div><div><br/></div><div>    /* Notify clients of device addition.  This call must come</div><div>     * after dpm_sysfs_add() and before kobject_uevent().</div><div>     */</div><div>    if (dev-&gt;bus)</div><div>        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</div><div>                         BUS_NOTIFY_ADD_DEVICE, dev);</div><div><br/></div><div>    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</div><div>    bus_probe_device(dev);</div><div>    if (parent)</div><div>        klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</div><div>                   &amp;parent-&gt;p-&gt;klist_children);</div><div><br/></div><div>    if (dev-&gt;class) {</div><div>        mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</div><div>        /* tie the class to the device */</div><div>        klist_add_tail(&amp;dev-&gt;knode_class,</div><div>                   &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</div><div><br/></div><div>        /* notify any interfaces that the device is here */</div><div>        list_for_each_entry(class_intf,</div><div>                    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</div><div>            if (class_intf-&gt;add_dev)</div><div>                class_intf-&gt;add_dev(dev, class_intf);</div><div>        mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</div><div>    }</div><div>done:</div><div>    put_device(dev);</div><div>    return error;</div><div> SysEntryError:</div><div>    if (MAJOR(dev-&gt;devt))</div><div>        device_remove_file(dev, &amp;dev_attr_dev);</div><div> DevAttrError:</div><div>    device_pm_remove(dev);</div><div>    dpm_sysfs_remove(dev);</div><div> DPMError:</div><div>    bus_remove_device(dev);</div><div> BusError:</div><div>    device_remove_attrs(dev);</div><div> AttrsError:</div><div>    device_remove_class_symlinks(dev);</div><div> SymlinkError:</div><div>    device_remove_file(dev, &amp;dev_attr_uevent);</div><div> attrError:</div><div>    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);</div><div>    kobject_del(&amp;dev-&gt;kobj);</div><div> Error:</div><div>    cleanup_device_parent(dev);</div><div>    put_device(parent);</div><div>name_error:</div><div>    kfree(dev-&gt;p);</div><div>    dev-&gt;p = NULL;</div><div>    goto done;</div><div>}</div><div>EXPORT_SYMBOL_GPL(device_add);</div></div><div><br/></div><div>4.那么在用户空间调用open,ioctl,read操作都会调用到驱动层的ashmem_open, ashmem_ioctl,ashmem_read函数了</div><div>，就完成从用户空间到内核空间的调用。</div></en-note>
]]></content><created>20180109T030923Z</created><updated>20180109T034545Z</updated><note-attributes><latitude>22.53658994004795</latitude><longitude>114.0505415789147</longitude><altitude>10.77074527740479</altitude><author>雅字杀手</author><source>desktop.mac</source><reminder-order>0</reminder-order></note-attributes></note>
</en-export>
